{"title":"飞机射击小游戏","date":"2019-08-31T06:09:00.000Z","author":"Xinyi Zhang","link":"post/飞机射击小游戏-1","updated":"2019-08-31T06:32:24.734Z","content":"<p>fsObject.h:</p>\n<pre><code>#pragma once\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#ifndef FSOBJECTS_H\n#define FSOBJECTS_H\n\nusing namespace std;\n\nnamespace flightShooting\n{\n#define FSOBJECTS_H\n#define FS_DEFAULT_FIRE_INTERVAL std::chrono::milliseconds(500)  // 默认的开火间隔\n#define FS_DEFAULT_FRAME_INTERVAL 10 // 默认的刷新频率，即每隔多少毫秒刷新一次\n#define FS_DEFAULT_MOVE_STEP 0.01   // 在moveleft()方法和moveright()方法中默认的每次移动距离\n#define FS_MOVE_LEFT_KEY &apos;a&apos;  // 控制玩家飞机向左移动一个单位所对应的按键\n#define FS_MOVE_RIGHT_KEY &apos;d&apos; // 控制玩家飞机向右移动一个单位所对应的按键\n#define FS_ESCAPE_KEY &apos; &apos;  // 退出游戏所使用的按键\n#define FS_DEFAULT_BULLET_FLY_SPEED 3.0  // 默认子弹飞行速度，3代表每秒飞行三个屏幕\n#define FS_DEFAULT_AIRCRAFT_FLY_SPEED 0.1  // 默认的飞机飞行速度\n#define FS_DEFAULT_BULLET_COLOR fsColor(255,0,0,0)  // 默认子弹颜色\n#define FS_DEFAULT_BULLET_SIZE 0.1 //默认的子弹正方形边长\n#define FS_DEFAULT_BULLET_SIZE_X 0.05 //默认的子弹长方形在x轴方向的长度\n#define FS_DEFAULT_BULLET_SIZE_Y 0.1 //默认的子弹长方形在y轴方向的长度\n#define FS_DEFAULT_PLAYER_SYMBOL &apos;*&apos;  // 默认的玩家的飞机的符号\n#define FS_DEFAULT_ENEMY_SYMBOL &apos;+&apos; // 默认的敌人的飞机的符号\n#define FS_DEFAULT_BULLET_SYMBOL &apos;o&apos; // 默认的子弹的符号\n#define FS_DEFAULT_SCOREBOARD_COLOR fsColor(0,255,0,0)  // 默认的计分版颜色\n// 默认的边界位置，这些位置主要在move*方法中限制物体不要超出屏幕边界\n#define FS_DEFAULT_COORD_LOWER_LIMIT 0.05\n#define FS_DEFAULT_COORD_UPPER_LIMIT 0.95\n#define FS_DEFAULT_COORD_LOWER_LIMIT_X 0.05\n#define FS_DEFAULT_COORD_UPPER_LIMIT_X 0.95\n#define FS_DEFAULT_COORD_LOWER_LIMIT_Y 0.05\n#define FS_DEFAULT_COORD_UPPER_LIMIT_Y 0.95\n// 飞机子弹来源\ntemplate&lt;typename T&gt;\nclass fsPoint\n{\npublic:\n    T x, y;\n    fsPoint() {};\n    fsPoint(T xval, T yval) :x(xval), y(yval) {};\n    fsPoint&lt;T&gt; &amp; operator = (const fsPoint&lt;T&gt; &amp; rval) {\n        this-&gt;x = rval.x;\n        this-&gt;y = rval.y;\n        return *this;\n    }\n};\n//飞机子弹的来源\nenum bulletSource\n{\n    player = 1, enemy = 2, playerFriend = 3//分别来自玩家、敌方、玩家朋友\n};\n//子弹射击方向\nenum direction\n{\n    up = 1, down = 2, right = 3, left = 4\n};\n/*enum symbol\n{\n    play = FS_DEFAULT_PLAYER_SYMBOL,en= FS_DEFAULT_ENEMY_SYMBOL,bullet=FS_DEFAULT_BULLET_SYMBOL\n\n};\n*/\nclass fsInvalidInitializePointValException : public std::logic_error {\npublic:\n    fsInvalidInitializePointValException() :std::logic_error(&quot;Invalid initialze fsPoints!&quot;) {};\n};\n\nclass fsOutRangeMoveToPointException : public std::logic_error {\npublic:\n    fsOutRangeMoveToPointException() : std::logic_error(&quot;the move to point is out of the range of 0 to 1 for either x or y&quot;) {};\n};\n\nclass fsInvalidFireTimeException :public std::logic_error {\npublic:\n    fsInvalidFireTimeException() :std::logic_error(&quot;Not right time to fire!&quot;) {};\n};\n\nclass fsInvalidBulletSpeedInException : public std::logic_error {\npublic:\n    fsInvalidBulletSpeedInException() : std::logic_error(&quot;bullet speed in must be a positive number!&quot;) {};\n};\nclass fsColor {\npublic:\n    unsigned char r, g, b, a;  //全部为0~255  0 表示完全不透明\n    fsColor() {};\n    fsColor(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) :\n        r(red), g(green), b(blue), a(alpha) {};\n};\n//游戏中所用物体的基类\nclass fsObject {\nprivate:\n    fsPoint&lt;double&gt; upperLeftCorner;  // the position \n    fsPoint&lt;double&gt; lowerRightCorner;\n    fsColor            foregroundColor;\n    char            symbol;\n    int                visible;  // 物体是否可见，如果为0则不可见\npublic:\n    fsObject() {};\n    //物体的位置、颜色、符号\n    fsObject(const fsPoint&lt;double&gt; &amp;upperleft, const fsPoint&lt;double&gt; &amp;lowerright, const fsColor &amp;fgc, char sym = 0)\n    {\n        if (upperleft.x &gt; lowerright.x || upperleft.y &gt; lowerright.y)\n            throw fsInvalidInitializePointValException();\n        this-&gt;upperLeftCorner = upperleft;\n        this-&gt;lowerRightCorner = lowerright;\n        this-&gt;foregroundColor = fgc;\n        this-&gt;symbol = sym;\n        this-&gt;visible = 1;\n    }\n    //获得左上角位置\n    fsPoint&lt;double&gt; getUpperLeftCorner() const { return this-&gt;upperLeftCorner; }\n    //获得右下角位置\n    fsPoint&lt;double&gt; getLowerRightCorner() const { return this-&gt;lowerRightCorner; }\n    //获得符号\n    char getSymbol() const { return this-&gt;symbol; }\n    //设置符号\n    void setSymbol(char c) { this-&gt;symbol = c; }\n    //设置为可见\n    int getVisible() const { return this-&gt;visible; }\n    //获得是否可见\n    void setVisible(int newVisible) { this-&gt;visible = newVisible; return; }\n    // 移动位置，向左移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0\n    int moveleft() {\n        if (this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP &lt; 0)\n            return 0;\n        this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP;\n        this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x - FS_DEFAULT_MOVE_STEP;\n        return 1;\n    }\n    // 移动位置，向右移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0\n    int moveright() {\n        if (this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP &gt; 1)\n            return 0;\n        this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + FS_DEFAULT_MOVE_STEP;\n        this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP;\n        return 1;\n    }\n    //检测竖直方向上移位是否正确\n    int moveVertically(double delta) {\n        if (this-&gt;upperLeftCorner.y + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_Y) {\n            this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_UPPER_LIMIT_Y;\n            return 0;\n        }\n        if (this-&gt;upperLeftCorner.y + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_Y) {\n            this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_LOWER_LIMIT_Y;\n            return 0;\n        }\n        this-&gt;upperLeftCorner.y = this-&gt;upperLeftCorner.y + delta;\n        this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.y + delta;\n        return 1;\n    }\n    //在水平方向上移动位置，如果输入的delta导致物体的左上角超出屏幕，就将其置为最近的FS_DEFAULT_COORD_UPPER_LIMIT_X或FS_DEFAULT_COORD_UPPER_LIMIT_X\n    int moveHorizontally(double delta) {\n        if (this-&gt;upperLeftCorner.x + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_X) {\n            this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_UPPER_LIMIT_X;\n            return 0;\n        }\n        if (this-&gt;upperLeftCorner.x + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_X) {\n            this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_LOWER_LIMIT_X;\n            return 0;\n        }\n        this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + delta;\n        this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + delta;\n        return 1;\n    }\n    //将物体的右下角移动到一点\n    int movePoint(const fsPoint&lt;double&gt; &amp;dest)\n    {\n        if (dest.x &gt; 1 || dest.x &lt; 0 || dest.y &gt;1 || dest.y &lt; 0) {\n            throw fsOutRangeMoveToPointException();\n        }\n        this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + dest.x - this-&gt;upperLeftCorner.x;\n        this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.x + dest.y - this-&gt;upperLeftCorner.y;\n        this-&gt;upperLeftCorner = dest;\n    }\n    void printpos() const\n    { cout &lt;&lt; &quot;ULC:&quot; &lt;&lt; (this-&gt;getLowerRightCorner()).x &lt;&lt; &quot;  &quot; &lt;&lt; (this-&gt;getLowerRightCorner()).y &lt;&lt; endl;\n    return;\n    }\n};\n//子弹类\nclass fsBullet :public fsObject {\nprivate:\n    fsObject bullet;\n    bulletSource source;\n    direction bulletDirection;  // 飞行方向\n    double vec; // 飞行速度，目前暂时不允许子弹斜着飞 并且不允许是负数\n    int bulletDamage;\n    std::chrono::high_resolution_clock::time_point lastPositionUpdateTime;\npublic:\n    fsBullet() {};\n    fsBullet(bulletSource sourceOfBullet, direction directionOfBullet, int damageOfBullet, fsPoint&lt;double&gt; sourceulc,\n        double bulletVec = FS_DEFAULT_BULLET_FLY_SPEED) :\n        fsObject(sourceulc, fsPoint&lt;double&gt;(sourceulc.x + FS_DEFAULT_BULLET_SIZE_X, sourceulc.y + FS_DEFAULT_BULLET_SIZE_Y), FS_DEFAULT_BULLET_COLOR),\n        source(sourceOfBullet),\n        bulletDirection(directionOfBullet), bulletDamage(damageOfBullet),\n        lastPositionUpdateTime(std::chrono::high_resolution_clock::now()) {\n        if (bulletVec &lt; 0)\n            throw fsInvalidBulletSpeedInException();\n        this-&gt;vec = bulletVec;\n        if (this-&gt;bulletDirection == up)\n            vec = vec * -1;\n        bullet.setSymbol(FS_DEFAULT_BULLET_SYMBOL);\n    }\n    //更新子弹位置\n    int updataPosition() {\n        std::chrono::microseconds timeelapsed = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::high_resolution_clock::now() - this-&gt;lastPositionUpdateTime);\n        double delta = 1.0 * timeelapsed.count() / 1000000 * vec;\n        //cout &lt;&lt; &quot;delta&quot; &lt;&lt; delta &lt;&lt; endl;\n        this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now();\n        if (bullet.moveVertically(delta) == 0)\n            return 0;\n        return 1;\n    }\n};\n//所有飞机的基类\nclass fsAircraft :public fsObject {\nprivate:\n    chrono::milliseconds fireInterval; // 两发炮弹之间的间隔，单位为ms\n    chrono::steady_clock::time_point lastFireTime;\n    int lifeLeft = 1;  // 剩余的生命值\n    int bulletDamage = 1;  // 默认的机体伤害值\n    bulletSource source;\n    direction bullteDirection;\npublic:\n    fsAircraft() {};\n    fsAircraft(fsPoint&lt;double&gt; upperleft,  // 飞机左上角的位置\n        fsPoint&lt;double&gt; lowerright,   // 飞机右下角的位置\n        fsColor fgc,  // 飞机的显示颜色，在控制台中此参数无效\n        std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL  // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹\n    ) :\n        fsObject(upperleft, lowerright, fgc),\n        fireInterval(fireinterval) {\n        this-&gt;lastFireTime = chrono::high_resolution_clock::now();\n    };\n    inline int fireReady() {\n        if (chrono::high_resolution_clock::now() - this-&gt;lastFireTime &gt; fireInterval)\n        {\n            return 1;\n        }\n        return 0;\n    }\n    // 强制发射子弹，返回fsBullet的对象，即该飞机所发射的子弹\n    fsBullet fire() {\n        //if (fireReady()) {\n        this-&gt;lastFireTime = chrono::high_resolution_clock::now();\n        return fsBullet(this-&gt;source, this-&gt;bullteDirection, this-&gt;bulletDamage, this-&gt;getUpperLeftCorner());\n        //}\n        //throw fsInvalidFireTimeException();\n    }\n    int setBullteDamage(int newBulletDamage) {\n        this-&gt;bulletDamage = newBulletDamage;\n        return 0;\n    }\n    // 设置飞机是玩家的飞机还是敌人的飞机\n    void setSource(bulletSource newSource) { this-&gt;source = newSource; }\n    // 设置新的子弹飞行方向\n    void setFireDirection(direction newDirection) { this-&gt;bullteDirection = newDirection; }\n\n    //返回剩余生命值，当返回0或者负数时说明死亡（本程序中没有使用）\n    int getLifeLeft() const {\n        return this-&gt;lifeLeft;\n    }\n    int gotHit(int bulletDamage = 1) {\n        if (this-&gt;lifeLeft - bulletDamage &lt;= 0) {\n            this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage;\n            return 0;\n        }\n        this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage;\n    }\n};\n//玩家的飞机\nclass fsMyAircraft :public fsAircraft {\npublic:\n    fsMyAircraft(fsPoint&lt;double&gt; upperleft,  // 飞机左上角的位置\n        fsPoint&lt;double&gt; lowerright,   // 飞机右下角的位置\n        fsColor fgc,   // 飞机的显示颜色，在控制台中此参数无效\n        std::chrono::milliseconds  fireinterval = FS_DEFAULT_FIRE_INTERVAL  // 飞机的子弹发射间隔，发射子弹后，再经过此段时间后才能再次发射子弹\n    ) :\n        fsAircraft(upperleft, lowerright, fgc, fireinterval) {\n        this-&gt;setSource(player);\n        this-&gt;setFireDirection(up);\n        this-&gt;setSymbol(FS_DEFAULT_PLAYER_SYMBOL);\n    };\n};\n//敌方的飞机\nclass fsEnemyAircraft : public fsAircraft {\nprivate:\n    std::chrono::high_resolution_clock::time_point lastPositionUpdateTime;  // 最后一次更新物体位置的时间\n    std::chrono::high_resolution_clock::time_point lastDirectionUpdateTime;  // 最后一次更新运动方向的时间\n    double vec; // 飞行速度，指在水平方向上的飞行速度\n    std::chrono::milliseconds directionUpdateInterval;  // 两次速度方向更新之间的时间间隔，最好能用随机数产生\npublic:\n    fsEnemyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置\n        fsPoint&lt;double&gt; lowerright,  // 飞机右下角的位置\n        fsColor fgc,  // 飞机的显示颜色，在控制台中此参数无效\n        std::chrono::milliseconds  fireinterval = FS_DEFAULT_FIRE_INTERVAL  // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹\n    ) :\n        fsAircraft(upperleft, lowerright, fgc, fireinterval) {\n        this-&gt;setSource(enemy);\n        this-&gt;setFireDirection(down);\n        this-&gt;setSymbol(FS_DEFAULT_ENEMY_SYMBOL);\n        this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now();\n        this-&gt;lastDirectionUpdateTime = std::chrono::high_resolution_clock::now();\n        this-&gt;directionUpdateInterval = std::chrono::milliseconds(1000);\n        this-&gt;vec = FS_DEFAULT_AIRCRAFT_FLY_SPEED;\n    }\n\n    // 更新敌机的位置，敌机随机移动，每隔一段时间更换一个方向，移动会在一个矩形框中进行\n    int updatePosition() {\n        // 是否要更换方向\n        if (std::chrono::high_resolution_clock::now() - lastDirectionUpdateTime &gt; directionUpdateInterval) {\n            //产生一个新的方向\n            lastDirectionUpdateTime = std::chrono::high_resolution_clock::now();\n            this-&gt;vec = this-&gt;vec * (-1);\n            srand((unsigned)time(NULL));\n            directionUpdateInterval = std::chrono::milliseconds(rand() / 5 + 1000);  // 随机数的范围在1s到7s之间\n        }\n        std::chrono::milliseconds elapsedtime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - lastPositionUpdateTime);\n        lastPositionUpdateTime = std::chrono::high_resolution_clock::now();\n        this-&gt;moveHorizontally(1.0 * elapsedtime.count() / 1000 * vec);\n        return 0;\n    }\n};\n// 计分版 用于记录玩家的分数\nclass fsScoreBoard : public fsObject {\nprivate:\n    int score = 0;  // 每次击中算一分\n\npublic:\n    fsScoreBoard() {};\n    fsScoreBoard(const fsPoint&lt;double&gt; &amp; upperleft, // 计分版左上角的位置 推荐将左上角的横坐标设置为大于1的数，避免分数的显示与游戏画面重叠\n        const fsPoint&lt;double&gt; &amp; lowerright,  // 计分版右下角的位置\n        const fsColor &amp; fgc = FS_DEFAULT_SCOREBOARD_COLOR  // 计分版颜色，在控制台情况下无效\n    ) :fsObject(upperleft, lowerright, fgc) {\n        ;\n    }\n\n    // 获取计分版分数\n    int getCurScore() const {\n        return this-&gt;score;\n    }\n    // 增加得分\n    void addScore(int delta = 1) {\n        this-&gt;score = this-&gt;score + 1;\n    }\n};\n\n// 判断两个物体是否重叠 如果重叠将返回1 否则返回0，主要用来判定子弹是否击中了飞机\nint fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) ;\n// 判断一个点是否在一个矩形中，包括在矩形边上的情况\ntemplate &lt;typename T&gt;\nbool fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight);\n\nint fsInitialize();\n//int fsGameLoop();\n}\n#endif</code></pre><p>fsDraw.h：</p>\n<pre><code>#pragma once\n#include &quot;fsObject.h&quot;\n#include &lt;Windows.h&gt;\n#include &lt;conio.h&gt;\n#ifndef FSDRAW_H\n#define FSDRAW_H\n\nusing namespace flightShooting;\nusing namespace std;\nnamespace flightShooting {\n#define FS_DEFAULT_CONSOLE_BUFFER_SCALE 50\n//光标位置\nvoid gotoxy(int x, int y)\n{\n    COORD pos;\n    pos.X = x;\n    pos.Y = y;\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);\n}\nvoid gotoxy(int x, int y, HANDLE consoleBuf) {\n    COORD pos;\n    pos.X = x;\n    pos.Y = y;\n    SetConsoleCursorPosition(consoleBuf, pos);\n}\n//设置颜色\nvoid setcolor(WORD color)\n{\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\n}\nvoid setcolor(WORD color, HANDLE consoleBuf) {\n    SetConsoleTextAttribute(consoleBuf, color);\n}\n//画出对象\nint fsDraw(const fsObject &amp; fso) {\n    if (fso.getVisible() == 0) return 0;\n    gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE,\n        (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE);\n    setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED);\n    cout &lt;&lt; fso.getSymbol();\n    return 0;\n}\nint fsDraw(const fsObject &amp; fso, HANDLE consoleBuf) {\n    if (fso.getVisible() == 0) return 0;\n    gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE,\n        (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf);\n    setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED, consoleBuf);\n    cout &lt;&lt; fso.getSymbol();\n    return 0;\n}\n\n//画出计分板\nint fsDrawScoreBoard(const fsScoreBoard &amp;fsb)\n{\n    if (fsb.getVisible() == 0) return 0;\n    gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE,\n        (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE);\n    setcolor(FOREGROUND_GREEN);\n    cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore();\n    return 0;\n}\nint fsDrawScoreBoard(const fsScoreBoard &amp; fsb, HANDLE consoleBuf) {\n    if (fsb.getVisible() == 0) return 0;\n    gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE,\n        (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf);\n    setcolor(FOREGROUND_GREEN, consoleBuf);\n    cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore();\n    return 0;\n}\n// 用空格填充控制台的缓存\nint fsFillWithBlank() {\n    gotoxy(0, 0);\n    for (int i = 0; i &lt; 1000 * 1000; ++i) {\n        cout &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}</code></pre><p>   }</p>\n<pre><code>#endif</code></pre><p>test.h:</p>\n<pre><code>int gameTestOneBuf() {\n// 初始化玩家飞机\nfsMyAircraft playerAircraft = fsMyAircraft(fsPoint&lt;double&gt;(0.5, 0.99),\n    fsPoint&lt;double&gt;(0.51, 1.00),\n    fsColor(255, 255, 255, 0));\n// 初始化敌方飞机\nfsEnemyAircraft enemy1 = fsEnemyAircraft(fsPoint&lt;double&gt;(0.5, 0.10),\n    fsPoint&lt;double&gt;(0.51, 0.11),\n    fsColor(255, 0, 0, 0));\n// 初始化计分板\nfsScoreBoard scoreBoard = fsScoreBoard(fsPoint&lt;double&gt;(1.1, 0.3), fsPoint&lt;double&gt;(1.11, 0.31));\n// 等待1s以便能够通过fire函数成功初始化子弹\nSleep(1000);\nfsBullet mybullet;\nif (playerAircraft.fireReady()) {\n    mybullet = playerAircraft.fire();\n}\nfsBullet enemybullet;\nif (enemy1.fireReady()) {\n    enemybullet = enemy1.fire();\n}\n// 初始化键盘按键存储变量\nchar ch = &apos;/0&apos;;\n\n// 游戏循环\nwhile (1) {\n    // 获取按键\n    if (_kbhit())\n    {\n        ch =_getche();\n\n    }\n    // 依据不同的按键做出对应的反应\n    switch (ch)\n    {\n    case FS_MOVE_LEFT_KEY:\n        playerAircraft.moveleft();\n        break;\n    case FS_MOVE_RIGHT_KEY:\n        playerAircraft.moveright();\n        break;\n    case FS_ESCAPE_KEY:\n        cout &lt;&lt; &quot;You ended this game!&quot;;\n        return 0;\n    default:\n        break;\n    }\n    ch = 0;\n    // 更新各对象的状态\n    if (playerAircraft.fireReady()) {\n        mybullet = playerAircraft.fire();\n    }\n    if (enemy1.fireReady()) {\n        enemybullet = enemy1.fire();\n    }\n    mybullet.updataPosition();\n    enemybullet.updataPosition();\n    enemy1.updatePosition();\n\n    // 呈现图像\n    system(&quot;cls&quot;);\n    fsDraw(playerAircraft);\n    fsDraw(mybullet);\n    fsDraw(enemy1);\n    fsDraw(enemybullet);\n    fsDrawScoreBoard(scoreBoard);\n    // 子弹击中的判定，如果子弹击中，则将原来的子弹设为不可见\n    if (fsOverlap(mybullet, enemy1)) {\n        scoreBoard.addScore();\n        mybullet.setVisible(0);\n    }\n    if (fsOverlap(enemybullet, playerAircraft)) {\n        cout &lt;&lt; &quot;you are hit!&quot;;\n        enemybullet.setVisible(0);\n        Sleep(500);\n    }\n    Sleep(FS_DEFAULT_FRAME_INTERVAL);\n}\nreturn 0;\n}</code></pre><p>fsObject.cpp:</p>\n<pre><code>#include &quot;pch.h&quot;\n#include &lt;iostream&gt;\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#include &lt;chrono&gt;\n#include &lt;vector&gt;\n#include &lt;conio.h&gt;\n#include &quot;fsObject.h&quot;\nusing namespace std;\nusing namespace flightShooting;\n\n\nint flightShooting::fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2)\n{\nif (obj1.getVisible() == 0 || obj2.getVisible() == 0) return 0;\n// 重叠判定要稍微费点脑筋\n// 判断矩形是否重叠，只需要对每个矩形，分别判断其四个顶点是否在另外一个矩形内\nconst fsPoint&lt;double&gt; obj1ulc = obj1.getUpperLeftCorner();\nconst fsPoint&lt;double&gt; obj1lrc = obj1.getLowerRightCorner();\nconst fsPoint&lt;double&gt; obj1urc = fsPoint&lt;double&gt;(obj1lrc.x, obj1ulc.y);\nconst fsPoint&lt;double&gt; obj1llc = fsPoint&lt;double&gt;(obj1ulc.x, obj1lrc.y);\n\nconst fsPoint&lt;double&gt; obj2ulc = obj2.getUpperLeftCorner();\nconst fsPoint&lt;double&gt; obj2lrc = obj2.getLowerRightCorner();\nconst fsPoint&lt;double&gt; obj2urc = fsPoint&lt;double&gt;(obj2lrc.x, obj2ulc.y);\nconst fsPoint&lt;double&gt; obj2llc = fsPoint&lt;double&gt;(obj2ulc.x, obj2lrc.y);\n\n//    bool test = fsPointInRect(obj1lrc, obj2ulc, obj2lrc);\nbool obj1InObj2 = fsPointInRect(obj1ulc, obj2ulc, obj2lrc) ||\n    fsPointInRect(obj1urc, obj2ulc, obj2lrc) ||\n    fsPointInRect(obj1llc, obj2ulc, obj2lrc) ||\n    fsPointInRect(obj1lrc, obj2ulc, obj2lrc);\nbool obj2InObj1 = fsPointInRect(obj2ulc, obj1ulc, obj1lrc) ||\n    fsPointInRect(obj2urc, obj1ulc, obj1lrc) ||\n    fsPointInRect(obj2llc, obj1ulc, obj1lrc) ||\n    fsPointInRect(obj2lrc, obj1ulc, obj1lrc);\nreturn obj1InObj2 || obj2InObj1;\n}\n\ntemplate&lt;typename T&gt;\nbool flightShooting::fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight)\n{\nreturn (point.x &gt;= RectUpperLeft.x &amp;&amp; point.x &lt;= RectLowerRight.x) &amp;&amp; (point.y &gt;= RectUpperLeft.y &amp;&amp; point.y &lt;= RectLowerRight.y);\n}</code></pre><p>fsTest.cpp:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &quot;pch.h&quot;\n#include &quot;fsObject.h&quot;\n#include &quot;fsTest.h&quot;\nusing namespace std;\nusing namespace flightShooting;\n\nint main() {\ngameTestOneBuf();\nreturn 0;}</code></pre>","next":{"title":"银行排队问题","link":"post/银行排队问题"},"plink":"http://yoursite.com/post/飞机射击小游戏-1/"}