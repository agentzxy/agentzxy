{"pages":[],"posts":[{"title":"Ananagrams-Uva 156","text":"输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文 本中的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中 的大小写，按字典序进行排列（所有大写字母在所有小写字母的前面）。 #样例输入： ladder came tape soon leader acme RIDE lone Dreis peat ScAlE orb eye Rides dealer NotE derail LaCeS drIednoel dire Disk mace Rob dries #样例输出： Disk NotE derail drIed eye ladder soon #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;algorithm&gt; using namespace std; string change(string s){ string s1=&quot;&quot;; for (int i = 0; i &lt; s.length(); i++) { s1+= tolower(s[i]); } sort(s1.begin(),s1.end()); return s1; } int main(){ string s; int i = 0, j = 0; vector&lt;string&gt; vec; vec.push_back(&quot;&quot;); getline(cin, s); while (true) { if (s[j] == &apos;#&apos;) break; else if (s[j] == &apos; &apos;) { i++; vec.push_back(&quot;&quot;); } else vec[i] += s[j]; j++; } map&lt;string, int&gt; m; vector&lt;string&gt; out; int count = vec.size(); for (i = 0; i &lt; count; i++) { string r = change(vec[i]); if (m.count(r)) { m[r] = 1; } m.insert(pair&lt;string, int&gt;(r, 0)); } for (i = 0; i &lt; vec.size(); i++) { if (m[change(vec[i])] == 0) { out.push_back(vec[i]); } } sort(out.begin(), out.end()); for (i = 0; i &lt; out.size(); i++) cout &lt;&lt; out[i] &lt;&lt; endl; return 0; }","link":"/2020/01/11/TL相关题/"},{"title":"java小作业-简单计算器","text":"java课上老师布置的小作业，一个简单计算器的实现，挺简单的。 代码如下： package com.company; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.lang.String; import java.util.Stack; public class GridL extends JFrame{ static Font ff=new Font(&quot;幼圆&quot;,Font.BOLD,30); public GridL(String title) { super(title); setLayout(new BorderLayout()); JPanel p=new JPanel(); TextField t=new TextField(300); add(&quot;North&quot;,t); add(p); GridLayout g=new GridLayout(4, 4); p.setLayout(g); for (int i = 1; i &lt;= 3; i++) { JButton b2 = new JButton(i+&quot;&quot;); String input=i+&quot;&quot;; //result=i; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+input); } }); p.add(b2); b2.setFont(ff); } JButton b1 = new JButton(&quot;-&quot;); b1.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;-&quot;); } }); p.add(b1); b1.setFont(ff); for (int i = 4; i &lt;= 6; i++){ JButton b2 = new JButton(i+&quot;&quot;); String input=i+&quot;&quot;; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s = t.getText(); t.setText(s + input); } }); p.add(b2); b2.setFont(ff); } JButton b3 = new JButton(&quot;+&quot;); b3.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;+&quot;); } }); p.add(b3); b3.setFont(ff); for (int i = 7; i &lt;= 9; i++) { JButton b2 = new JButton(i + &quot;&quot;); String input = i + &quot;&quot;; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s = t.getText(); t.setText(s + input); } }); p.add(b2); b2.setFont(ff); } JButton b4 = new JButton(&quot;*&quot;); b4.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;*&quot;); } }); b4.setFont(ff); p.add(b4); JButton b5 = new JButton(&quot;.&quot;); b5.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;.&quot;); } }); b5.setFont(ff); p.add(b5); JButton b6 = new JButton(&quot;*&quot;); b6.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;0&quot;); } }); b6.setFont(ff); p.add(b6); JButton b7 = new JButton(&quot;=&quot;); b7.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); int result=0; Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); stack.push((int) (s.charAt(0)-&apos;0&apos;)); for(int i=1;i&lt;s.length()-1;i++) { char ch = s.charAt(i); if (ch == &apos;+&apos;) { stack.push((int) (s.charAt(i + 1) - &apos;0&apos;)); } else if (ch == &apos;-&apos;) { stack.push((int) -1 * (s.charAt(i + 1) - &apos;0&apos;)); } else if (ch == &apos;*&apos;) { int num = stack.peek(); stack.pop(); stack.push((int) num * (s.charAt(i + 1) - &apos;0&apos;)); } else if (ch == &apos;/&apos;) { int num = stack.peek(); stack.pop(); stack.push((int) num / (s.charAt(i + 1) - &apos;0&apos;)); } } while(!stack.empty()){ result=result+stack.peek(); stack.pop(); } t.setText(result+&quot;&quot;); } }); b7.setFont(ff); p.add(b7); JButton b8 = new JButton(&quot;/&quot;); b8.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;/&quot;); } }); b8.setFont(ff); p.add(b8); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public static void main(String[] args) { GridL frm=new GridL(&quot;计算器&quot;); frm.setSize(300,350); frm.setVisible(true); } }界面也很简单： 大二刚转专业时有一门课叫做程序设计上机实践，是利用C#来写，第一个小作业就是实现一个简单计算器。当时刚转专业，除了大一学习的C++，之前也没怎么接触过计算机。所以开始看见这个项目是一脸懵逼的，全程都是抄的别人的，看也看不懂。 一年过去了，现在大三，还是很菜鸡，但比起大二刚转专业算是入门了吧。整个大二都在学习中度过，因为大二上学期成绩下滑厉害，所以即便是下学期拼命追赶也无法保研，真的很多情绪只能自己体会。现在也放弃保研了，要准备考研，但不后悔大二做的一切。 哈哈哈，做完这个小作业后有感而发","link":"/2019/12/06/ava小作业-简单计算器/"},{"title":"scrapy框架爬取豆瓣电影top250","text":"在items里主要有五个item：序号、电影名字、电影标签、评分、图片url 由于只爬取了电影，所以movie.py里只有电影这一个spider。里面的parse函数利用xpath将搜索出来的数据导入items里的各个item的列表中，具体代码如下： def parse(self, response): html=response.text html=etree.HTML(html) order=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div/em&apos;)#序号 title=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;pic&quot;]/a/img/@alt&apos;) inq=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;info&quot;]/div[@class=&quot;bd&quot;]/p[@class=&quot;quote&quot;]/span&apos;) rating_num=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;info&quot;]/div[@class=&quot;bd&quot;]/div/span[@class=&quot;rating_num&quot;]&apos;) image_url=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;pic&quot;]/a/img/@src&apos;) item=movieItem() item[&apos;nums&apos;]=order item[&apos;names&apos;]=title item[&apos;tags&apos;]=inq item[&apos;scores&apos;]=rating_num item[&apos;images&apos;]=image_url yield item 注意一定要yield item，不然无法对items里面的进行数据处理 然后就是利用pipeline对数据处理，分为三个，分别是原始的、传入mysql的、将剧照保存的。 传入mysql： def process_item(self,item,spider): for i in range(24): sql=&quot;INSERT INTO top250(NUM,NAME,TAG,SCORE) VALUES(%s,%s,%s,%s)&quot; num=item[&apos;nums&apos;][i].text name=item[&apos;names&apos;][i] tag=item[&apos;tags&apos;][i].text score=item[&apos;scores&apos;][i].text s=(num,name,tag,score) self.cursor.execute(sql,s) self.db.commit() return item 保存图片的： def process_item(self,item,spider): for i in range(24): splitPath=item[&apos;images&apos;][i].split(&apos;.&apos;) fTail=splitPath.pop() fileName=item[&apos;names&apos;][i]+&quot;.&quot;+fTail filepath=&quot;D:/ddddd/&quot;+fileName request.urlretrieve(item[&apos;images&apos;][i],filepath) 最后就是在settings里面设置一些参数，具体代码参见github","link":"/2019/11/14/crapy框架爬取豆瓣电影top250/"},{"title":"自制简单操作系统（3）","text":"今天主要是实现鼠标的移动，昨天写的是中断后直接跳转到中断处理程序，处理过程也在那个函数里面。今天改良了，使用缓冲区来实现（其实就是栈）,比如键盘按下一个键后，将发送的字节送入缓冲区，然后在主函数里面，读出存储的字节，这样就可以实现不停的按下键，并且读入字节。利用结构体实现一个缓冲区。 鼠标移动就会发送出三个字节，第一个字节是点击和移动鼠标的，第二个字节是x值，第三个是y值（位置），也可以将鼠标发送的字节存储在缓冲区内，然后读出。利用读出的xy值将鼠标隐藏，然后重新绘制鼠标。 当鼠标一移动，就会发出中断，因为先前设置了鼠标的中断号码和响应函数，即可响应中断，但其实我不太明白GDT为什么要初始化。 里面还涉及到鼠标和键盘的控制电路的初始化，激活鼠标，因为键盘控制电路中含有鼠标控制电路，所以获取鼠标发送的字节和键盘一样。 关于控制电路初始化那块不太明白，感觉鼠标移动还是很好理解的。 成果图：","link":"/2019/12/09/制简单操作系统（3）/"},{"title":"自制简单操作系统（1）","text":"我是跟着川合秀实的《30天自制操作系统》做的，感觉这本书挺好的，比较易懂，打算在博客记录下我的学习过程。 主要是用C语言写，有些C语言没有的功能，比如HLT指令之类的，就需要用汇编嵌入C语言中。 首先制作启动区，0x7c00-0x7dff用于启动区，写一个汇编语言程序，并且将它转成机器语言。主要功能是能读取软盘的10个柱面（当然我并没有买软盘，是用的作者提供的一个模拟器），如果读取错误则显示出error。 接着开始写程序。使用C语言编写，里面有整个操作系统颜色定义，现在只定义了16种颜色，但足够了，将颜色读入显卡的内存地址，BIOS里面定义VRAM（显卡内存）是0xa0000-0xaffff的64KB，依次读入就可以了。里面有的中断设置和使CPU休眠的HLT指令要利用汇编完成。 C语言编写后将其转成nas文件（作者自己命名的，相当于汇编语言文件），然后再将nas文件转为机器语言即可。 为了不会出现很多批处理文件，使用了Makefile，在makefile文件里面执行命令，将nas文件转成bin文件，将C的源文件转成gas，把gas再转为nas文件，nas转obj目标文件，接着就可以转二进制映像了。 nas文件用nask编译后可输出sys文件，将sys文件与做成的映像文件作比较可以发现，一般向一个空软盘保存文件时，文件名会写在0x002600以后的地方，文件内容会写在0x004200以后的地方（我觉得的也就是程序的意思）. 成果：","link":"/2019/12/07/制简单操作系统（1）-1/"},{"title":"自制简单操作系统（2）","text":"今天主要是学习中断处理程序的制作，以键盘和鼠标为例，键盘输入后，CPU进行中断处理。 GDT是记录段号的，一共64KB，每个段分配8个字节，用20位记录段大小。32位记录段起始地址，12位记录段的管理信息。然后进行初始化。 PIC是可编程中断控制器，一般来说CPU只能单独的处理一个中断，PIC将8个中断信号集合成一个，PIC分为主PIC和从PIC，从PIC连接到主PIC的一个端口。首先要将PIC初始化，将主从PIC全部禁止、ICW的初始化，其中可以利用ICW2来使PIC设定中断号，例如主PIC的0-7端口由INT20-INT27来接收。 IDT是记录0-255的中断号码与调用函数的关系。同理将IDT初始化，IDT中记录了把一个中断后执行的程序注册到IDT的多少号、中断执行、管理信息。 写一个函数将鼠标和键盘中断的GDT和IDT初始化，将每段的信息利用for循环存入GDT中，再将键盘和鼠标注册到IDT的第21和2c号。如果发生中断，CPU就自动调用利用汇编编写的相应的中断处理函数。 在主函数中，允许键盘中断和鼠标终端，具体就是将值送到PIC的主从端口，设定中断号，这样一旦有键按下，就会触发中断执行，然后由于键盘在IDT中注册了中断号，所以就会触发程序执行。 成果图如下： 但鼠标不知道为什么不能执行中断。 上面讲的肯定有很多不对的地方，也有一些地方是模糊的，继续往后做，我觉得肯定能越来越明白的。","link":"/2019/12/08/制简单操作系统（2）/"},{"title":"自制简单操作系统（4）","text":"今天学习的是内存管理。首先是内存检查，把值写入内存再反转，观察值是否改变，若没变就代表内存没问题，利用for循环将每个内存地址都写入值。 然后是内存管理，本系统采用的是将每个空闲内存的起始地址和空闲大小记录下来，可以利用结构体来完成。再用一个结构体记录所有空闲内存的情况，然后进行初始化、内存分配和释放内存。采用这种方式记录内存使用情况只用消耗32KB的内存，所以是不错的。 成果图如下：","link":"/2019/12/11/制简单操作系统（4）/"},{"title":"自制简单操作系统（5）","text":"这次增加了图层的应用，用来进行画面的叠加处理。同样也是利用结构体完成，SHEET结构体记录每个图层的信息，SHTCTL结构体记录了所有图层的信息。然后首先给每个图层分配相应的内存空间。将图层的显示顺序从次到主依次排序，显示越底层的，内存分配的起始地址越小。接着将每个图层绘制处理，每个图层都有自己的显示buf，将其在整个显示屏上绘制出来。鼠标一移动，就要刷新图层，重新绘制所有图层。也正因为这样，让鼠标动得有点一闪一闪的，所以还得优化一下，明天做优化内容。 成果图如下： 由于图层分配了内存，所以可用内存又减少了。","link":"/2019/12/13/制简单操作系统（5）/"},{"title":"自制简单操作系统（6）","text":"这次主要是将鼠标移动优化和做出一个计时器的窗口。 之前由于每移动一次鼠标就需要将整个画面重新绘制，导致鼠标不太灵敏，画面有些一顿一顿。为了优化鼠标移动，我们将绘制整个画面缩小为只绘制移动的画面。写三个函数，分别是刷新整个画面的某一部分、刷新一个图层的某一部分、有移动后刷新，依次调用上一个函数即可。 计时器就是显示数字，不断地for循环。难点是每次刷新时总是先要绘制背景，才能显示数字，所以每次显示数字前会有背景色覆盖。所以这里引入了map，主要是记录每个像素点属于哪一个图层，重新绘制时只需要绘制指定的图层即可。具体做法是在绘制每一层图层时，如果map记录的是该图层，就可以绘制。 下面总结一下图层的应用： 分别由两个结构体SHEET和SHTCTL，SHEET是记录每个图层的信息，参数有该图层的每个像素点的地址、图层长宽、图层位置、图层透明度、图层高度（高度越高，显示越靠前）、是否可见、该图层所属的图层体。SHTCTL我将它成为图层体，图层体里有很多图层，参数有图层体大小、图层体里的图层最高高度、数组记录每个图层位置、每个图层。 首先将图层图层体初始化，在内存中分配地址，再将图层体分配给一个个图层并且初始化。如果有移动，则重新绘制移动部分的该图层。图层不要了就要释放所占的内存。 成果图如下：","link":"/2019/12/16/制简单操作系统（6）/"},{"title":"利用Flask框架写一个简单的预约系统","text":"主要功能就是用户登录、管理员登录、利用邮箱注册、增加或取消个人或团体预约记录。系统不难做，但有时候有些点会卡着你一个多小时。 登录是通过查询数据库的结果为1来验证。注册邮箱时碰到一个问题卡了我很久，因为我发送验证码和注册两个都是提交到同一个页面，当注册submit时，由于前面发送验证码已经submit，所以此时填写的email等信息会为空，所以我利用了session机制，如果页面接收到的email等信息不为空，则将其加入session，等到为空时，直接利用session的值来提交到数据库。 同样的用户登录后，回退页面也要用session机制，将用户名和密码存储在其中，过期时间为10分钟。 在注册时发送的验证码应存储在redis数据库中，设置一个过期时间为60s，此时不建议用mysql之类的关系数据库，没必要。 这个预约系统是在档案馆值班的时间做的，挺有收获的，做完了回头看确实很简单，算是对web开发有了初步接触了。 具体代码见https://github.com/agentzxy/reservation-system.git","link":"/2019/12/05/用Flask框架写一个简单的预约系统/"},{"title":"控制台实现贪吃蛇","text":"1.首先要有定义坐标的类，坐标类里参数包括(x,y)。 2.其次定义snake类。用蛇身各点坐标描述蛇的位置，可将蛇的位置分为蛇头和蛇身来描述，蛇头为一个坐标点，使用#表示，蛇身为一个数组，数组各值表示蛇身各点位置。再定义几个成员函数，包括蛇的上下左右移动、蛇吃到食物后变长、蛇直径前行、判断蛇是否出边界或撞向自己、蛇是否吃到食物、显示蛇的图案。 3.然后定义一些函数。有界面上围墙的形成、光标的移动、食物的随机产生。 4.最后通过主函数的调用实现。 cpp： #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &lt;Windows.h&gt; #define n 20 #include &lt;conio.h&gt; #include&lt;time.h&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include &quot;stdlib.h&quot; using namespace std; //控制光标 void gotoxy(int x, int y) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(consoleBuf, pos); } //坐标类 template&lt;typename T&gt; class sPoint { public: T x, y; sPoint() {}; sPoint(T xval, T yval) :x(xval), y(yval) {}; sPoint&lt;T&gt; &amp; operator = (const sPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this; } }; //方向 enum Direction { left=&apos;a&apos;,right=&apos;d&apos; }; //随机产生一个食物 double * setFood() { double *a=new double[2]; int x, y; srand(time(0));//随机种子 do { x = rand() % 50 + 1; y = rand() % 30 + 1; break; } while (1); gotoxy(x, y); a[0] = x; a[1] = y;//将生成的食物坐标存储起来 std::cout &lt;&lt; &apos;0&apos; ; return a; } //生成围墙 void getWall() { sPoint&lt;double&gt; wall; wall.x = 0; wall.y =0; while (wall.y &lt;= 30) { gotoxy(50,wall.y); std::cout &lt;&lt; &quot;|&quot;; wall.y++; } gotoxy(0, 30); while (wall.x &lt;= 50) { std::cout &lt;&lt; &quot;-&quot;; wall.x++; } } //蛇类 class Snake { private: sPoint&lt;double&gt; snakeHead;//蛇头的位置 sPoint&lt;double&gt; snakeTail;//蛇尾的位置 sPoint&lt;double&gt; snakeBody[n];//蛇身各点 //int forwardTime;//前进的时间间隔 Direction direction; char sym; int last; public: Snake() {}; Snake(sPoint&lt;double&gt; head, sPoint&lt;double&gt; tail,int Last,sPoint&lt;double&gt; body[n]) { this-&gt;snakeHead = head; this-&gt;snakeTail = tail; this-&gt;last = Last; this-&gt;snakeBody[20] = body[20]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; snakeBody[0].x = 15; snakeBody[0].y = 15; snakeBody[1].x = 16; snakeBody[1].y = 15; snakeBody[2].x = 17; snakeBody[2].y = 15; snakeBody[3].x = 18; snakeBody[3].y = 15; last = 4; } //蛇向左转 void setSnakeLeft() { //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.x = snakeHead.x - 1; snakeHead.y = snakeHead.y; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向右转 void setSnakeRight() { //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y; snakeHead.x = snakeHead.x+1; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向上转 void setSnakeUp() { for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y - 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向下转 void setSnakeDown() { for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y + 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇直走 void setSnakeForward() { if (snakeBody[0].y &lt; snakeBody[1].y) snakeHead.y = snakeHead.y - 1; if (snakeBody[0].y &gt; snakeBody[1].y) snakeHead.y = snakeHead.y + 1; if (snakeBody[0].x &lt; snakeBody[1].x) snakeHead.x = snakeHead.x - 1; if (snakeBody[0].x &gt; snakeBody[1].x) snakeHead.x = snakeHead.x + 1; for (int i = last; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇身加一点 void addSnake() { if (snakeBody[last - 1].y &lt; snakeBody[last - 2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y--; } if (snakeBody[last -1].y &gt; snakeBody[last -2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y++; } if (snakeBody[last -1].x &lt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x--; } if (snakeBody[last -1].x &gt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x++; } last++; snakeHead.x = snakeBody[0].x; snakeHead.y = snakeBody[0].y; } //判断蛇是否撞墙或撞自己 int ifOut() { //蛇是否到达边界 if (snakeBody[0].x == 50 || snakeBody[0].y == 30 || snakeBody[0].x == 0 || snakeBody[0].y == 0) return 0; //判断蛇是否撞到自己 for (int j = 1; j &lt;last; j++) { if ((snakeHead.x == snakeBody[j].x)&amp;&amp;(snakeHead.y == snakeBody[j].y)) return 0; } return 1; } //初步显示蛇的图案 void snakeDisplay() { gotoxy(snakeBody[0].x, snakeBody[0].y); std::cout &lt;&lt; &quot;*&quot;;//显示蛇头 for (int a = 1; a &lt; last; a++) { //std::cout &lt;&lt; this-&gt;snakeBody[a].x &lt;&lt; this-&gt;snakeBody[a].y; gotoxy(snakeBody[a].x, snakeBody[a].y); std::cout &lt;&lt; &quot;#&quot;; } } //判断蛇是否吃到食物 int ifEat(double x,double y) { if (this-&gt;snakeHead.x == x&amp;&amp;this-&gt;snakeHead.y == y) return true; else return false; } }; int main() { double x, y, *a; sPoint&lt;double&gt; body[20];//用于存储身体各点坐标 system(&quot;cls&quot;); getWall(); Snake snake = Snake(sPoint&lt;double&gt;(15, 15), sPoint&lt;double&gt;(18, 15), 4, body);//初始化蛇 snake.snakeDisplay(); a=setFood(); x = a[0]; y = a[1]; char ch = &apos;/0&apos;; Sleep(5000); //当没有键按下，蛇往前走 while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(&quot;cls&quot;); getWall(); gotoxy(x,y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; setFood(); snake.snakeDisplay(); } if (!snake.ifOut()) return 0; } while (1) { if (_kbhit()) { ch = _getche();//ch记录按下的键是什么 switch (ch) { case &apos;d&apos;: snake.setSnakeRight(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;a&apos;: snake.setSnakeLeft(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;w&apos;: snake.setSnakeUp(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;s&apos;: snake.setSnakeDown(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;p&apos;: return 0; default: break; } } while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; setFood(); snake.snakeDisplay(); } } if (!snake.ifOut()) return 0; if (snake.ifEat(x,y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); a=setFood(); x = a[0]; y = a[1]; snake.snakeDisplay(); } } return 0; }","link":"/2019/09/03/控制台实现贪吃蛇/"},{"title":"自制简单操作系统（7）","text":"这次学习了定时器的设置和加快中断处理。与鼠标键盘一样，定时器是通过中断处理实现的。有一个类似于8253的计数器，不停的向cpu发送脉冲，每接受一次脉冲就产生一次中断。定时器也是用结构体实现。每个定时器设有一个超时变量，当初始化计数器后就开始计数，如果数目达到了某个定时器的超时变量，就代表该定时器已经到达设定的时间，就可以往定时器设定的缓冲区发送字节（与键盘鼠标类似）。一旦发现该缓冲区有字节后就开始执行特定的命令。这就是定时器的基本工作原理。加快中断处理是针对定时器的中断。主要是将每个定时器按照超时的大小进行排序存储（与图层设定类似），这样每次判断该定时器是否工作或到达设定时间时，就可以少执行几次for循环。以下是这次实验的成果图：","link":"/2019/12/18/自制简单操作系统（7）/"},{"title":"自制简单操作系统（8）","text":"这次学习的仍然是定时器，以及提高性能。首先是测试性能，在判断中断的for循环里进行count++计数，当到了10秒之后就将count值显示出来，但在5秒处要归零（作者是在3秒处归零），这是因为电脑初始化所花费的时间有很大变化。然后通过优化FIFO缓冲区来进行性能提升。因为鼠标、键盘、各个定时器的中断，都使用了不同的缓冲区，这样在判断的时候就会很麻烦，所以采用同一个缓冲区，但往缓冲区送入的不同数字代表不同的中断。最后是加快定时器的中断处理，使用了线性链表和哨兵。我在这里总结一下定时器所采用的结构和方法（提升性能后有所变化）：定时器的结构体参数有：下一个超时的定时器、超时时间、使用标记、中断处理的缓冲区、该中断的数字号。定时器控制体的结构体参数有：计时器、下一个的超时时间、第一个定时器、存放500个定时器的数组。首先是初始化定时器：给每个定时器分配（就是存放500个定时器数组里的标志设为1），设置哨兵，往中断缓冲存入该定时器对应的数字号。若有中断到达则往缓冲区存入数字，并且将下一个会到达的超时定时器指定。由于定时器是线性链表结构排列，所以当有一个新的定时器加入时，要将新定时器插入链表，按照顺序排列。以下是成果图：","link":"/2019/12/21/自制简单操作系统（8）/"},{"title":"递归问题","text":"最近数据结构刚刚学了递归问题，感觉理解的不太到位，刚好leetcode刷题刷到了两个递归问题，对递归算是更进一步理解了吧。 leetcode—22.括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 当加入一个左括号时，剩余的可看作新的组合，但右括号的个数必须大于左括号的个数时，才表明可以加入右括号，C++代码如下： vector&lt;string&gt; res; void back(string s,int i,int j){ int n; if(i==0&amp;&amp;j==0) { res.push_back(s); return; } if(i&gt;0) back(s+&apos;(&apos;,i-1,j); if(j&gt;i) back(s+&apos;)&apos;,i,j-1); } vector&lt;string&gt; generateParenthesis(int n) { back(&quot;&quot;,n,n); return res; }leetcode—39.组合总数 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 利用递归求解，将数组中的第一个数提取出来，则可以看作是求candidates中所有可以使数字和为（target-第一个数字）的组合，以此类推，但必须注意不能有重复的组合，所以应该在后面的数被提取时，不能与前面的数相匹配。C++代码如下： vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { com(0,candidates,target); return res; } void com(int cur,vector&lt;int&gt;&amp; candidates,int target) { int t; t=target; for(int i=cur;i&lt;candidates.size();i++) { if(target==0) { res.push_back(tmp); return; } if(target&gt;0) { tmp.push_back(candidates[i]); com(i,candidates,target-candidates[i]); tmp.pop_back(); } else continue; target=t; } }","link":"/2019/06/02/递归问题/"},{"title":"飞机射击小游戏","text":"fsObject.h: #pragma once #include &lt;iostream&gt; #include &lt;chrono&gt; #ifndef FSOBJECTS_H #define FSOBJECTS_H using namespace std; namespace flightShooting { #define FSOBJECTS_H #define FS_DEFAULT_FIRE_INTERVAL std::chrono::milliseconds(500) // 默认的开火间隔 #define FS_DEFAULT_FRAME_INTERVAL 10 // 默认的刷新频率，即每隔多少毫秒刷新一次 #define FS_DEFAULT_MOVE_STEP 0.01 // 在moveleft()方法和moveright()方法中默认的每次移动距离 #define FS_MOVE_LEFT_KEY &apos;a&apos; // 控制玩家飞机向左移动一个单位所对应的按键 #define FS_MOVE_RIGHT_KEY &apos;d&apos; // 控制玩家飞机向右移动一个单位所对应的按键 #define FS_ESCAPE_KEY &apos; &apos; // 退出游戏所使用的按键 #define FS_DEFAULT_BULLET_FLY_SPEED 3.0 // 默认子弹飞行速度，3代表每秒飞行三个屏幕 #define FS_DEFAULT_AIRCRAFT_FLY_SPEED 0.1 // 默认的飞机飞行速度 #define FS_DEFAULT_BULLET_COLOR fsColor(255,0,0,0) // 默认子弹颜色 #define FS_DEFAULT_BULLET_SIZE 0.1 //默认的子弹正方形边长 #define FS_DEFAULT_BULLET_SIZE_X 0.05 //默认的子弹长方形在x轴方向的长度 #define FS_DEFAULT_BULLET_SIZE_Y 0.1 //默认的子弹长方形在y轴方向的长度 #define FS_DEFAULT_PLAYER_SYMBOL &apos;*&apos; // 默认的玩家的飞机的符号 #define FS_DEFAULT_ENEMY_SYMBOL &apos;+&apos; // 默认的敌人的飞机的符号 #define FS_DEFAULT_BULLET_SYMBOL &apos;o&apos; // 默认的子弹的符号 #define FS_DEFAULT_SCOREBOARD_COLOR fsColor(0,255,0,0) // 默认的计分版颜色 // 默认的边界位置，这些位置主要在move*方法中限制物体不要超出屏幕边界 #define FS_DEFAULT_COORD_LOWER_LIMIT 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_X 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_X 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_Y 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_Y 0.95 // 飞机子弹来源 template&lt;typename T&gt; class fsPoint { public: T x, y; fsPoint() {}; fsPoint(T xval, T yval) :x(xval), y(yval) {}; fsPoint&lt;T&gt; &amp; operator = (const fsPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this; } }; //飞机子弹的来源 enum bulletSource { player = 1, enemy = 2, playerFriend = 3//分别来自玩家、敌方、玩家朋友 }; //子弹射击方向 enum direction { up = 1, down = 2, right = 3, left = 4 }; /*enum symbol { play = FS_DEFAULT_PLAYER_SYMBOL,en= FS_DEFAULT_ENEMY_SYMBOL,bullet=FS_DEFAULT_BULLET_SYMBOL }; */ class fsInvalidInitializePointValException : public std::logic_error { public: fsInvalidInitializePointValException() :std::logic_error(&quot;Invalid initialze fsPoints!&quot;) {}; }; class fsOutRangeMoveToPointException : public std::logic_error { public: fsOutRangeMoveToPointException() : std::logic_error(&quot;the move to point is out of the range of 0 to 1 for either x or y&quot;) {}; }; class fsInvalidFireTimeException :public std::logic_error { public: fsInvalidFireTimeException() :std::logic_error(&quot;Not right time to fire!&quot;) {}; }; class fsInvalidBulletSpeedInException : public std::logic_error { public: fsInvalidBulletSpeedInException() : std::logic_error(&quot;bullet speed in must be a positive number!&quot;) {}; }; class fsColor { public: unsigned char r, g, b, a; //全部为0~255 0 表示完全不透明 fsColor() {}; fsColor(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) : r(red), g(green), b(blue), a(alpha) {}; }; //游戏中所用物体的基类 class fsObject { private: fsPoint&lt;double&gt; upperLeftCorner; // the position fsPoint&lt;double&gt; lowerRightCorner; fsColor foregroundColor; char symbol; int visible; // 物体是否可见，如果为0则不可见 public: fsObject() {}; //物体的位置、颜色、符号 fsObject(const fsPoint&lt;double&gt; &amp;upperleft, const fsPoint&lt;double&gt; &amp;lowerright, const fsColor &amp;fgc, char sym = 0) { if (upperleft.x &gt; lowerright.x || upperleft.y &gt; lowerright.y) throw fsInvalidInitializePointValException(); this-&gt;upperLeftCorner = upperleft; this-&gt;lowerRightCorner = lowerright; this-&gt;foregroundColor = fgc; this-&gt;symbol = sym; this-&gt;visible = 1; } //获得左上角位置 fsPoint&lt;double&gt; getUpperLeftCorner() const { return this-&gt;upperLeftCorner; } //获得右下角位置 fsPoint&lt;double&gt; getLowerRightCorner() const { return this-&gt;lowerRightCorner; } //获得符号 char getSymbol() const { return this-&gt;symbol; } //设置符号 void setSymbol(char c) { this-&gt;symbol = c; } //设置为可见 int getVisible() const { return this-&gt;visible; } //获得是否可见 void setVisible(int newVisible) { this-&gt;visible = newVisible; return; } // 移动位置，向左移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveleft() { if (this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP &lt; 0) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x - FS_DEFAULT_MOVE_STEP; return 1; } // 移动位置，向右移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveright() { if (this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP &gt; 1) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP; return 1; } //检测竖直方向上移位是否正确 int moveVertically(double delta) { if (this-&gt;upperLeftCorner.y + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_UPPER_LIMIT_Y; return 0; } if (this-&gt;upperLeftCorner.y + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_LOWER_LIMIT_Y; return 0; } this-&gt;upperLeftCorner.y = this-&gt;upperLeftCorner.y + delta; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.y + delta; return 1; } //在水平方向上移动位置，如果输入的delta导致物体的左上角超出屏幕，就将其置为最近的FS_DEFAULT_COORD_UPPER_LIMIT_X或FS_DEFAULT_COORD_UPPER_LIMIT_X int moveHorizontally(double delta) { if (this-&gt;upperLeftCorner.x + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_UPPER_LIMIT_X; return 0; } if (this-&gt;upperLeftCorner.x + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_LOWER_LIMIT_X; return 0; } this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + delta; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + delta; return 1; } //将物体的右下角移动到一点 int movePoint(const fsPoint&lt;double&gt; &amp;dest) { if (dest.x &gt; 1 || dest.x &lt; 0 || dest.y &gt;1 || dest.y &lt; 0) { throw fsOutRangeMoveToPointException(); } this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + dest.x - this-&gt;upperLeftCorner.x; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.x + dest.y - this-&gt;upperLeftCorner.y; this-&gt;upperLeftCorner = dest; } void printpos() const { cout &lt;&lt; &quot;ULC:&quot; &lt;&lt; (this-&gt;getLowerRightCorner()).x &lt;&lt; &quot; &quot; &lt;&lt; (this-&gt;getLowerRightCorner()).y &lt;&lt; endl; return; } }; //子弹类 class fsBullet :public fsObject { private: fsObject bullet; bulletSource source; direction bulletDirection; // 飞行方向 double vec; // 飞行速度，目前暂时不允许子弹斜着飞 并且不允许是负数 int bulletDamage; std::chrono::high_resolution_clock::time_point lastPositionUpdateTime; public: fsBullet() {}; fsBullet(bulletSource sourceOfBullet, direction directionOfBullet, int damageOfBullet, fsPoint&lt;double&gt; sourceulc, double bulletVec = FS_DEFAULT_BULLET_FLY_SPEED) : fsObject(sourceulc, fsPoint&lt;double&gt;(sourceulc.x + FS_DEFAULT_BULLET_SIZE_X, sourceulc.y + FS_DEFAULT_BULLET_SIZE_Y), FS_DEFAULT_BULLET_COLOR), source(sourceOfBullet), bulletDirection(directionOfBullet), bulletDamage(damageOfBullet), lastPositionUpdateTime(std::chrono::high_resolution_clock::now()) { if (bulletVec &lt; 0) throw fsInvalidBulletSpeedInException(); this-&gt;vec = bulletVec; if (this-&gt;bulletDirection == up) vec = vec * -1; bullet.setSymbol(FS_DEFAULT_BULLET_SYMBOL); } //更新子弹位置 int updataPosition() { std::chrono::microseconds timeelapsed = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::high_resolution_clock::now() - this-&gt;lastPositionUpdateTime); double delta = 1.0 * timeelapsed.count() / 1000000 * vec; //cout &lt;&lt; &quot;delta&quot; &lt;&lt; delta &lt;&lt; endl; this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); if (bullet.moveVertically(delta) == 0) return 0; return 1; } }; //所有飞机的基类 class fsAircraft :public fsObject { private: chrono::milliseconds fireInterval; // 两发炮弹之间的间隔，单位为ms chrono::steady_clock::time_point lastFireTime; int lifeLeft = 1; // 剩余的生命值 int bulletDamage = 1; // 默认的机体伤害值 bulletSource source; direction bullteDirection; public: fsAircraft() {}; fsAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsObject(upperleft, lowerright, fgc), fireInterval(fireinterval) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); }; inline int fireReady() { if (chrono::high_resolution_clock::now() - this-&gt;lastFireTime &gt; fireInterval) { return 1; } return 0; } // 强制发射子弹，返回fsBullet的对象，即该飞机所发射的子弹 fsBullet fire() { //if (fireReady()) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); return fsBullet(this-&gt;source, this-&gt;bullteDirection, this-&gt;bulletDamage, this-&gt;getUpperLeftCorner()); //} //throw fsInvalidFireTimeException(); } int setBullteDamage(int newBulletDamage) { this-&gt;bulletDamage = newBulletDamage; return 0; } // 设置飞机是玩家的飞机还是敌人的飞机 void setSource(bulletSource newSource) { this-&gt;source = newSource; } // 设置新的子弹飞行方向 void setFireDirection(direction newDirection) { this-&gt;bullteDirection = newDirection; } //返回剩余生命值，当返回0或者负数时说明死亡（本程序中没有使用） int getLifeLeft() const { return this-&gt;lifeLeft; } int gotHit(int bulletDamage = 1) { if (this-&gt;lifeLeft - bulletDamage &lt;= 0) { this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; return 0; } this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; } }; //玩家的飞机 class fsMyAircraft :public fsAircraft { public: fsMyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，发射子弹后，再经过此段时间后才能再次发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(player); this-&gt;setFireDirection(up); this-&gt;setSymbol(FS_DEFAULT_PLAYER_SYMBOL); }; }; //敌方的飞机 class fsEnemyAircraft : public fsAircraft { private: std::chrono::high_resolution_clock::time_point lastPositionUpdateTime; // 最后一次更新物体位置的时间 std::chrono::high_resolution_clock::time_point lastDirectionUpdateTime; // 最后一次更新运动方向的时间 double vec; // 飞行速度，指在水平方向上的飞行速度 std::chrono::milliseconds directionUpdateInterval; // 两次速度方向更新之间的时间间隔，最好能用随机数产生 public: fsEnemyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(enemy); this-&gt;setFireDirection(down); this-&gt;setSymbol(FS_DEFAULT_ENEMY_SYMBOL); this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;directionUpdateInterval = std::chrono::milliseconds(1000); this-&gt;vec = FS_DEFAULT_AIRCRAFT_FLY_SPEED; } // 更新敌机的位置，敌机随机移动，每隔一段时间更换一个方向，移动会在一个矩形框中进行 int updatePosition() { // 是否要更换方向 if (std::chrono::high_resolution_clock::now() - lastDirectionUpdateTime &gt; directionUpdateInterval) { //产生一个新的方向 lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;vec = this-&gt;vec * (-1); srand((unsigned)time(NULL)); directionUpdateInterval = std::chrono::milliseconds(rand() / 5 + 1000); // 随机数的范围在1s到7s之间 } std::chrono::milliseconds elapsedtime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - lastPositionUpdateTime); lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;moveHorizontally(1.0 * elapsedtime.count() / 1000 * vec); return 0; } }; // 计分版 用于记录玩家的分数 class fsScoreBoard : public fsObject { private: int score = 0; // 每次击中算一分 public: fsScoreBoard() {}; fsScoreBoard(const fsPoint&lt;double&gt; &amp; upperleft, // 计分版左上角的位置 推荐将左上角的横坐标设置为大于1的数，避免分数的显示与游戏画面重叠 const fsPoint&lt;double&gt; &amp; lowerright, // 计分版右下角的位置 const fsColor &amp; fgc = FS_DEFAULT_SCOREBOARD_COLOR // 计分版颜色，在控制台情况下无效 ) :fsObject(upperleft, lowerright, fgc) { ; } // 获取计分版分数 int getCurScore() const { return this-&gt;score; } // 增加得分 void addScore(int delta = 1) { this-&gt;score = this-&gt;score + 1; } }; // 判断两个物体是否重叠 如果重叠将返回1 否则返回0，主要用来判定子弹是否击中了飞机 int fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) ; // 判断一个点是否在一个矩形中，包括在矩形边上的情况 template &lt;typename T&gt; bool fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight); int fsInitialize(); //int fsGameLoop(); } #endiffsDraw.h： #pragma once #include &quot;fsObject.h&quot; #include &lt;Windows.h&gt; #include &lt;conio.h&gt; #ifndef FSDRAW_H #define FSDRAW_H using namespace flightShooting; using namespace std; namespace flightShooting { #define FS_DEFAULT_CONSOLE_BUFFER_SCALE 50 //光标位置 void gotoxy(int x, int y) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(consoleBuf, pos); } //设置颜色 void setcolor(WORD color) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color); } void setcolor(WORD color, HANDLE consoleBuf) { SetConsoleTextAttribute(consoleBuf, color); } //画出对象 int fsDraw(const fsObject &amp; fso) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED); cout &lt;&lt; fso.getSymbol(); return 0; } int fsDraw(const fsObject &amp; fso, HANDLE consoleBuf) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED, consoleBuf); cout &lt;&lt; fso.getSymbol(); return 0; } //画出计分板 int fsDrawScoreBoard(const fsScoreBoard &amp;fsb) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_GREEN); cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore(); return 0; } int fsDrawScoreBoard(const fsScoreBoard &amp; fsb, HANDLE consoleBuf) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_GREEN, consoleBuf); cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore(); return 0; } // 用空格填充控制台的缓存 int fsFillWithBlank() { gotoxy(0, 0); for (int i = 0; i &lt; 1000 * 1000; ++i) { cout &lt;&lt; &quot; &quot;; } return 0; } } #endiftest.h: int gameTestOneBuf() { // 初始化玩家飞机 fsMyAircraft playerAircraft = fsMyAircraft(fsPoint&lt;double&gt;(0.5, 0.99), fsPoint&lt;double&gt;(0.51, 1.00), fsColor(255, 255, 255, 0)); // 初始化敌方飞机 fsEnemyAircraft enemy1 = fsEnemyAircraft(fsPoint&lt;double&gt;(0.5, 0.10), fsPoint&lt;double&gt;(0.51, 0.11), fsColor(255, 0, 0, 0)); // 初始化计分板 fsScoreBoard scoreBoard = fsScoreBoard(fsPoint&lt;double&gt;(1.1, 0.3), fsPoint&lt;double&gt;(1.11, 0.31)); // 等待1s以便能够通过fire函数成功初始化子弹 Sleep(1000); fsBullet mybullet; if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } fsBullet enemybullet; if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } // 初始化键盘按键存储变量 char ch = &apos;/0&apos;; // 游戏循环 while (1) { // 获取按键 if (_kbhit()) { ch =_getche(); } // 依据不同的按键做出对应的反应 switch (ch) { case FS_MOVE_LEFT_KEY: playerAircraft.moveleft(); break; case FS_MOVE_RIGHT_KEY: playerAircraft.moveright(); break; case FS_ESCAPE_KEY: cout &lt;&lt; &quot;You ended this game!&quot;; return 0; default: break; } ch = 0; // 更新各对象的状态 if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } mybullet.updataPosition(); enemybullet.updataPosition(); enemy1.updatePosition(); // 呈现图像 system(&quot;cls&quot;); fsDraw(playerAircraft); fsDraw(mybullet); fsDraw(enemy1); fsDraw(enemybullet); fsDrawScoreBoard(scoreBoard); // 子弹击中的判定，如果子弹击中，则将原来的子弹设为不可见 if (fsOverlap(mybullet, enemy1)) { scoreBoard.addScore(); mybullet.setVisible(0); } if (fsOverlap(enemybullet, playerAircraft)) { cout &lt;&lt; &quot;you are hit!&quot;; enemybullet.setVisible(0); Sleep(500); } Sleep(FS_DEFAULT_FRAME_INTERVAL); } return 0; }fsObject.cpp: #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &lt;iostream&gt; #include &lt;Windows.h&gt; #include &lt;chrono&gt; #include &lt;vector&gt; #include &lt;conio.h&gt; #include &quot;fsObject.h&quot; using namespace std; using namespace flightShooting; int flightShooting::fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) { if (obj1.getVisible() == 0 || obj2.getVisible() == 0) return 0; // 重叠判定要稍微费点脑筋 // 判断矩形是否重叠，只需要对每个矩形，分别判断其四个顶点是否在另外一个矩形内 const fsPoint&lt;double&gt; obj1ulc = obj1.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj1lrc = obj1.getLowerRightCorner(); const fsPoint&lt;double&gt; obj1urc = fsPoint&lt;double&gt;(obj1lrc.x, obj1ulc.y); const fsPoint&lt;double&gt; obj1llc = fsPoint&lt;double&gt;(obj1ulc.x, obj1lrc.y); const fsPoint&lt;double&gt; obj2ulc = obj2.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj2lrc = obj2.getLowerRightCorner(); const fsPoint&lt;double&gt; obj2urc = fsPoint&lt;double&gt;(obj2lrc.x, obj2ulc.y); const fsPoint&lt;double&gt; obj2llc = fsPoint&lt;double&gt;(obj2ulc.x, obj2lrc.y); // bool test = fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj1InObj2 = fsPointInRect(obj1ulc, obj2ulc, obj2lrc) || fsPointInRect(obj1urc, obj2ulc, obj2lrc) || fsPointInRect(obj1llc, obj2ulc, obj2lrc) || fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj2InObj1 = fsPointInRect(obj2ulc, obj1ulc, obj1lrc) || fsPointInRect(obj2urc, obj1ulc, obj1lrc) || fsPointInRect(obj2llc, obj1ulc, obj1lrc) || fsPointInRect(obj2lrc, obj1ulc, obj1lrc); return obj1InObj2 || obj2InObj1; } template&lt;typename T&gt; bool flightShooting::fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight) { return (point.x &gt;= RectUpperLeft.x &amp;&amp; point.x &lt;= RectLowerRight.x) &amp;&amp; (point.y &gt;= RectUpperLeft.y &amp;&amp; point.y &lt;= RectLowerRight.y); }fsTest.cpp: #include &lt;iostream&gt; #include &quot;pch.h&quot; #include &quot;fsObject.h&quot; #include &quot;fsTest.h&quot; using namespace std; using namespace flightShooting; int main() { gameTestOneBuf(); return 0;}","link":"/2019/08/31/飞机射击小游戏-1/"},{"title":"银行排队问题","text":"要解决的问题——银行一天之内的： 1.总客户数 2.客户总逗留时间 3.客户平均逗留时间 银行排队问题可具体化为一个银行、队伍、客户，将客户到达事件、客户离开事件等一系列事件作为事件链表，客户作为链表节点，银行作为一个类。 bank头文件： #include &lt;queue&gt; #include &lt;list&gt; //事件链表 struct Event { int _occur_time;//事件发生时间 int _type;//事件类型，0表示到达事件，1~4表示4个窗口离开事件 }; //银行链表的队伍结点 struct QueueNode { int _arrival_time;//客户到达时间 int _duration_time;//客户在银行待的时间 }; //银行链表 class Bank { public: //防止隐式转化 explicit Bank(int window = 4, int close_time = 8 * 3600); ~Bank(); void Simulation(); private: int _queue_number; //队列个数 int _close_time; //关门时间 int _total_time;//所有客人待的总时间 int _customer_number;//客户数目 std::list&lt;Event&gt; _event_list;//事件链表 std::queue&lt;QueueNode&gt; *_work_queue;//工作队伍队列 void OpenForDay(); void CustomerArrival(Event *event);//客户到达事件 void CustomerDeparture(Event *event);//客户离开事件 int FindShortestQueue(); void SortEventList(); }; bank.cpp: #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &quot;bank.h&quot; #include &lt;clocale&gt; #include &lt;chrono&gt; #include &lt;cstdlib&gt; Bank::Bank(int window, int close_time) :_queue_number(window), _close_time(close_time), _total_time(0), _customer_number(0) { _work_queue = new std::queue&lt;QueueNode&gt;[window];//产生一个新的工作队列 srand(std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()));//产生伪随机序列 } Bank::~Bank() { delete[] _work_queue; } void Bank::OpenForDay() { //第一个客户到达,将第一个客户到达事件压入栈 _event_list.push_back({ 0,0 }); } void Bank::CustomerArrival(Event *event) { ++_customer_number;//客户数加一 int duration_time, inter_time;//inter_time:下一个客户隔多长时间来 duration_time = rand() % 1800 + 1;//一个客户最多30分钟 inter_time = rand() % 600 + 1;//最多10分钟来一个客户 //下一个客户到达时间 int t = event-&gt;_occur_time + inter_time; //假设银行未关门 if (t &lt; _close_time) { _event_list.push_back({ t,0 });//将下一个客户到达事件压栈 SortEventList();//整理、排序事件 } int i; i = FindShortestQueue();//i为最短队列 //将新客户压入最短队列 _work_queue[i].push({ event-&gt;_occur_time,duration_time }); //生成i队列最后一个人的离开事件 if (_work_queue[i].size() == 1) { _event_list.push_back({ event-&gt;_occur_time + duration_time,i + 1 }); SortEventList(); } } void Bank::CustomerDeparture(Event *event) { int i = event-&gt;_type - 1;//i表示1~4哪个队伍离开 QueueNode customer; //客户离开，从队伍中弹出 customer = _work_queue[i].front(); _work_queue[i].pop(); //客户总耗时=之前的耗时+此刻的耗时 _total_time += event-&gt;_occur_time - customer._arrival_time; if (!_work_queue[i].empty()) { customer = _work_queue[i].front(); _event_list.push_back( { customer._duration_time + event-&gt;_occur_time, i + 1 }); SortEventList(); } } int Bank::FindShortestQueue() { int result = 0; for (int i = 0; i &lt; _queue_number; ++i) { if (_work_queue[result].size() &gt; _work_queue[i].size()) result = i; } return result; } void Bank::SortEventList() { // Lambda表达式 _event_list.sort([](const Event &amp;e1, const Event &amp;e2) -&gt; bool {return e1._occur_time &lt; e2._occur_time; }); } //模拟仿真排队 void Bank::Simulation() { OpenForDay(); Event event; while (!_event_list.empty()) { event = _event_list.front(); _event_list.pop_front(); if (event._type == 0) // 到达事件 CustomerArrival(&amp;event); else CustomerDeparture(&amp;event); } // 计算并输出平均逗留时间 std::wcout &lt;&lt; L&quot;客户数：&quot; &lt;&lt; _customer_number &lt;&lt; std::endl &lt;&lt; L&quot;总逗留时间（小时）：&quot; &lt;&lt; (double)_total_time / 3600.0 &lt;&lt; std::endl &lt;&lt; L&quot;平均逗留时间（分钟）：&quot; &lt;&lt; (double)_total_time / (double)(_customer_number * 60) &lt;&lt; std::endl; } int wmain(int argc, wchar_t *argv[], wchar_t *env[]) { _wsetlocale(LC_ALL, L&quot;&quot;); Bank bank; bank.Simulation(); return 0; }","link":"/2019/08/28/银行排队问题/"}],"tags":[{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"c++","slug":"c","link":"/categories/c/"}]}