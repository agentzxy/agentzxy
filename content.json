{"pages":[],"posts":[{"title":"scrapy框架爬取豆瓣电影top250","text":"在items里主要有五个item：序号、电影名字、电影标签、评分、图片url 由于只爬取了电影，所以movie.py里只有电影这一个spider。里面的parse函数利用xpath将搜索出来的数据导入items里的各个item的列表中，具体代码如下： def parse(self, response): html=response.text html=etree.HTML(html) order=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div/em&apos;)#序号 title=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;pic&quot;]/a/img/@alt&apos;) inq=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;info&quot;]/div[@class=&quot;bd&quot;]/p[@class=&quot;quote&quot;]/span&apos;) rating_num=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;info&quot;]/div[@class=&quot;bd&quot;]/div/span[@class=&quot;rating_num&quot;]&apos;) image_url=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;pic&quot;]/a/img/@src&apos;) item=movieItem() item[&apos;nums&apos;]=order item[&apos;names&apos;]=title item[&apos;tags&apos;]=inq item[&apos;scores&apos;]=rating_num item[&apos;images&apos;]=image_url yield item 注意一定要yield item，不然无法对items里面的进行数据处理 然后就是利用pipeline对数据处理，分为三个，分别是原始的、传入mysql的、将剧照保存的。 传入mysql： def process_item(self,item,spider): for i in range(24): sql=&quot;INSERT INTO top250(NUM,NAME,TAG,SCORE) VALUES(%s,%s,%s,%s)&quot; num=item[&apos;nums&apos;][i].text name=item[&apos;names&apos;][i] tag=item[&apos;tags&apos;][i].text score=item[&apos;scores&apos;][i].text s=(num,name,tag,score) self.cursor.execute(sql,s) self.db.commit() return item 保存图片的： def process_item(self,item,spider): for i in range(24): splitPath=item[&apos;images&apos;][i].split(&apos;.&apos;) fTail=splitPath.pop() fileName=item[&apos;names&apos;][i]+&quot;.&quot;+fTail filepath=&quot;D:/ddddd/&quot;+fileName request.urlretrieve(item[&apos;images&apos;][i],filepath) 最后就是在settings里面设置一些参数，具体代码参见github","link":"/2019/11/14/crapy框架爬取豆瓣电影top250/"},{"title":"java小作业-简单计算器","text":"java课上老师布置的小作业，一个简单计算器的实现，挺简单的。 代码如下： package com.company; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.lang.String; import java.util.Stack; public class GridL extends JFrame{ static Font ff=new Font(&quot;幼圆&quot;,Font.BOLD,30); public GridL(String title) { super(title); setLayout(new BorderLayout()); JPanel p=new JPanel(); TextField t=new TextField(300); add(&quot;North&quot;,t); add(p); GridLayout g=new GridLayout(4, 4); p.setLayout(g); for (int i = 1; i &lt;= 3; i++) { JButton b2 = new JButton(i+&quot;&quot;); String input=i+&quot;&quot;; //result=i; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+input); } }); p.add(b2); b2.setFont(ff); } JButton b1 = new JButton(&quot;-&quot;); b1.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;-&quot;); } }); p.add(b1); b1.setFont(ff); for (int i = 4; i &lt;= 6; i++){ JButton b2 = new JButton(i+&quot;&quot;); String input=i+&quot;&quot;; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s = t.getText(); t.setText(s + input); } }); p.add(b2); b2.setFont(ff); } JButton b3 = new JButton(&quot;+&quot;); b3.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;+&quot;); } }); p.add(b3); b3.setFont(ff); for (int i = 7; i &lt;= 9; i++) { JButton b2 = new JButton(i + &quot;&quot;); String input = i + &quot;&quot;; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s = t.getText(); t.setText(s + input); } }); p.add(b2); b2.setFont(ff); } JButton b4 = new JButton(&quot;*&quot;); b4.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;*&quot;); } }); b4.setFont(ff); p.add(b4); JButton b5 = new JButton(&quot;.&quot;); b5.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;.&quot;); } }); b5.setFont(ff); p.add(b5); JButton b6 = new JButton(&quot;*&quot;); b6.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;0&quot;); } }); b6.setFont(ff); p.add(b6); JButton b7 = new JButton(&quot;=&quot;); b7.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); int result=0; Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); stack.push((int) (s.charAt(0)-&apos;0&apos;)); for(int i=1;i&lt;s.length()-1;i++) { char ch = s.charAt(i); if (ch == &apos;+&apos;) { stack.push((int) (s.charAt(i + 1) - &apos;0&apos;)); } else if (ch == &apos;-&apos;) { stack.push((int) -1 * (s.charAt(i + 1) - &apos;0&apos;)); } else if (ch == &apos;*&apos;) { int num = stack.peek(); stack.pop(); stack.push((int) num * (s.charAt(i + 1) - &apos;0&apos;)); } else if (ch == &apos;/&apos;) { int num = stack.peek(); stack.pop(); stack.push((int) num / (s.charAt(i + 1) - &apos;0&apos;)); } } while(!stack.empty()){ result=result+stack.peek(); stack.pop(); } t.setText(result+&quot;&quot;); } }); b7.setFont(ff); p.add(b7); JButton b8 = new JButton(&quot;/&quot;); b8.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+&quot;/&quot;); } }); b8.setFont(ff); p.add(b8); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public static void main(String[] args) { GridL frm=new GridL(&quot;计算器&quot;); frm.setSize(300,350); frm.setVisible(true); } }界面也很简单： 大二刚转专业时有一门课叫做程序设计上机实践，是利用C#来写，第一个小作业就是实现一个简单计算器。当时刚转专业，除了大一学习的C++，之前也没怎么接触过计算机。所以开始看见这个项目是一脸懵逼的，全程都是抄的别人的，看也看不懂。 一年过去了，现在大三，还是很菜鸡，但比起大二刚转专业算是入门了吧。整个大二都在学习中度过，因为大二上学期成绩下滑厉害，所以即便是下学期拼命追赶也无法保研，真的很多情绪只能自己体会。现在也放弃保研了，要准备考研，但不后悔大二做的一切。 哈哈哈，做完这个小作业后有感而发","link":"/2019/12/06/ava小作业-简单计算器/"},{"title":"自制简单操作系统（2）","text":"今天主要是学习中断处理程序的制作，以键盘和鼠标为例，键盘输入后，CPU进行中断处理。 GDT是记录段号的，一共64KB，每个段分配8个字节，用20位记录段大小。32位记录段起始地址，12位记录段的管理信息。然后进行初始化。 PIC是可编程中断控制器，一般来说CPU只能单独的处理一个中断，PIC将8个中断信号集合成一个，PIC分为主PIC和从PIC，从PIC连接到主PIC的一个端口。首先要将PIC初始化，将主从PIC全部禁止、ICW的初始化，其中可以利用ICW2来使PIC设定中断号，例如主PIC的0-7端口由INT20-INT27来接收。 IDT是记录0-255的中断号码与调用函数的关系。同理将IDT初始化，IDT中记录了把一个中断后执行的程序注册到IDT的多少号、中断执行、管理信息。 写一个函数将鼠标和键盘中断的GDT和IDT初始化，将每段的信息利用for循环存入GDT中，再将键盘和鼠标注册到IDT的第21和2c号。如果发生中断，CPU就自动调用利用汇编编写的相应的中断处理函数。 在主函数中，允许键盘中断和鼠标终端，具体就是将值送到PIC的主从端口，设定中断号，这样一旦有键按下，就会触发中断执行，然后由于键盘在IDT中注册了中断号，所以就会触发程序执行。 成果图如下： 但鼠标不知道为什么不能执行中断。 上面讲的肯定有很多不对的地方，也有一些地方是模糊的，继续往后做，我觉得肯定能越来越明白的。","link":"/2019/12/08/制简单操作系统（2）/"},{"title":"控制台实现贪吃蛇","text":"1.首先要有定义坐标的类，坐标类里参数包括(x,y)。 2.其次定义snake类。用蛇身各点坐标描述蛇的位置，可将蛇的位置分为蛇头和蛇身来描述，蛇头为一个坐标点，使用#表示，蛇身为一个数组，数组各值表示蛇身各点位置。再定义几个成员函数，包括蛇的上下左右移动、蛇吃到食物后变长、蛇直径前行、判断蛇是否出边界或撞向自己、蛇是否吃到食物、显示蛇的图案。 3.然后定义一些函数。有界面上围墙的形成、光标的移动、食物的随机产生。 4.最后通过主函数的调用实现。 cpp： #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &lt;Windows.h&gt; #define n 20 #include &lt;conio.h&gt; #include&lt;time.h&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include &quot;stdlib.h&quot; using namespace std; //控制光标 void gotoxy(int x, int y) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(consoleBuf, pos); } //坐标类 template&lt;typename T&gt; class sPoint { public: T x, y; sPoint() {}; sPoint(T xval, T yval) :x(xval), y(yval) {}; sPoint&lt;T&gt; &amp; operator = (const sPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this; } }; //方向 enum Direction { left=&apos;a&apos;,right=&apos;d&apos; }; //随机产生一个食物 double * setFood() { double *a=new double[2]; int x, y; srand(time(0));//随机种子 do { x = rand() % 50 + 1; y = rand() % 30 + 1; break; } while (1); gotoxy(x, y); a[0] = x; a[1] = y;//将生成的食物坐标存储起来 std::cout &lt;&lt; &apos;0&apos; ; return a; } //生成围墙 void getWall() { sPoint&lt;double&gt; wall; wall.x = 0; wall.y =0; while (wall.y &lt;= 30) { gotoxy(50,wall.y); std::cout &lt;&lt; &quot;|&quot;; wall.y++; } gotoxy(0, 30); while (wall.x &lt;= 50) { std::cout &lt;&lt; &quot;-&quot;; wall.x++; } } //蛇类 class Snake { private: sPoint&lt;double&gt; snakeHead;//蛇头的位置 sPoint&lt;double&gt; snakeTail;//蛇尾的位置 sPoint&lt;double&gt; snakeBody[n];//蛇身各点 //int forwardTime;//前进的时间间隔 Direction direction; char sym; int last; public: Snake() {}; Snake(sPoint&lt;double&gt; head, sPoint&lt;double&gt; tail,int Last,sPoint&lt;double&gt; body[n]) { this-&gt;snakeHead = head; this-&gt;snakeTail = tail; this-&gt;last = Last; this-&gt;snakeBody[20] = body[20]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; snakeBody[0].x = 15; snakeBody[0].y = 15; snakeBody[1].x = 16; snakeBody[1].y = 15; snakeBody[2].x = 17; snakeBody[2].y = 15; snakeBody[3].x = 18; snakeBody[3].y = 15; last = 4; } //蛇向左转 void setSnakeLeft() { //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.x = snakeHead.x - 1; snakeHead.y = snakeHead.y; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向右转 void setSnakeRight() { //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y; snakeHead.x = snakeHead.x+1; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向上转 void setSnakeUp() { for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y - 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向下转 void setSnakeDown() { for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y + 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇直走 void setSnakeForward() { if (snakeBody[0].y &lt; snakeBody[1].y) snakeHead.y = snakeHead.y - 1; if (snakeBody[0].y &gt; snakeBody[1].y) snakeHead.y = snakeHead.y + 1; if (snakeBody[0].x &lt; snakeBody[1].x) snakeHead.x = snakeHead.x - 1; if (snakeBody[0].x &gt; snakeBody[1].x) snakeHead.x = snakeHead.x + 1; for (int i = last; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇身加一点 void addSnake() { if (snakeBody[last - 1].y &lt; snakeBody[last - 2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y--; } if (snakeBody[last -1].y &gt; snakeBody[last -2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y++; } if (snakeBody[last -1].x &lt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x--; } if (snakeBody[last -1].x &gt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x++; } last++; snakeHead.x = snakeBody[0].x; snakeHead.y = snakeBody[0].y; } //判断蛇是否撞墙或撞自己 int ifOut() { //蛇是否到达边界 if (snakeBody[0].x == 50 || snakeBody[0].y == 30 || snakeBody[0].x == 0 || snakeBody[0].y == 0) return 0; //判断蛇是否撞到自己 for (int j = 1; j &lt;last; j++) { if ((snakeHead.x == snakeBody[j].x)&amp;&amp;(snakeHead.y == snakeBody[j].y)) return 0; } return 1; } //初步显示蛇的图案 void snakeDisplay() { gotoxy(snakeBody[0].x, snakeBody[0].y); std::cout &lt;&lt; &quot;*&quot;;//显示蛇头 for (int a = 1; a &lt; last; a++) { //std::cout &lt;&lt; this-&gt;snakeBody[a].x &lt;&lt; this-&gt;snakeBody[a].y; gotoxy(snakeBody[a].x, snakeBody[a].y); std::cout &lt;&lt; &quot;#&quot;; } } //判断蛇是否吃到食物 int ifEat(double x,double y) { if (this-&gt;snakeHead.x == x&amp;&amp;this-&gt;snakeHead.y == y) return true; else return false; } }; int main() { double x, y, *a; sPoint&lt;double&gt; body[20];//用于存储身体各点坐标 system(&quot;cls&quot;); getWall(); Snake snake = Snake(sPoint&lt;double&gt;(15, 15), sPoint&lt;double&gt;(18, 15), 4, body);//初始化蛇 snake.snakeDisplay(); a=setFood(); x = a[0]; y = a[1]; char ch = &apos;/0&apos;; Sleep(5000); //当没有键按下，蛇往前走 while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(&quot;cls&quot;); getWall(); gotoxy(x,y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; setFood(); snake.snakeDisplay(); } if (!snake.ifOut()) return 0; } while (1) { if (_kbhit()) { ch = _getche();//ch记录按下的键是什么 switch (ch) { case &apos;d&apos;: snake.setSnakeRight(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;a&apos;: snake.setSnakeLeft(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;w&apos;: snake.setSnakeUp(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;s&apos;: snake.setSnakeDown(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;p&apos;: return 0; default: break; } } while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; setFood(); snake.snakeDisplay(); } } if (!snake.ifOut()) return 0; if (snake.ifEat(x,y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); a=setFood(); x = a[0]; y = a[1]; snake.snakeDisplay(); } } return 0; }","link":"/2019/09/03/控制台实现贪吃蛇/"},{"title":"自制简单操作系统（1）","text":"我是跟着川合秀实的《30天自制操作系统》做的，感觉这本书挺好的，比较易懂，打算在博客记录下我的学习过程。 主要是用C语言写，有些C语言没有的功能，比如HLT指令之类的，就需要用汇编嵌入C语言中。 首先制作启动区，0x7c00-0x7dff用于启动区，写一个汇编语言程序，并且将它转成机器语言。主要功能是能读取软盘的10个柱面（当然我并没有买软盘，是用的作者提供的一个模拟器），如果读取错误则显示出error。 接着开始写程序。使用C语言编写，里面有整个操作系统颜色定义，现在只定义了16种颜色，但足够了，将颜色读入显卡的内存地址，BIOS里面定义VRAM（显卡内存）是0xa0000-0xaffff的64KB，依次读入就可以了。里面有的中断设置和使CPU休眠的HLT指令要利用汇编完成。 C语言编写后将其转成nas文件（作者自己命名的，相当于汇编语言文件），然后再将nas文件转为机器语言即可。 为了不会出现很多批处理文件，使用了Makefile，在makefile文件里面执行命令，将nas文件转成bin文件，将C的源文件转成gas，把gas再转为nas文件，nas转obj目标文件，接着就可以转二进制映像了。 nas文件用nask编译后可输出sys文件，将sys文件与做成的映像文件作比较可以发现，一般向一个空软盘保存文件时，文件名会写在0x002600以后的地方，文件内容会写在0x004200以后的地方（我觉得的也就是程序的意思）. 成果：","link":"/2019/12/07/制简单操作系统（1）-1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/02/hello-world/"},{"title":"利用Flask框架写一个简单的预约系统","text":"主要功能就是用户登录、管理员登录、利用邮箱注册、增加或取消个人或团体预约记录。系统不难做，但有时候有些点会卡着你一个多小时。 登录是通过查询数据库的结果为1来验证。注册邮箱时碰到一个问题卡了我很久，因为我发送验证码和注册两个都是提交到同一个页面，当注册submit时，由于前面发送验证码已经submit，所以此时填写的email等信息会为空，所以我利用了session机制，如果页面接收到的email等信息不为空，则将其加入session，等到为空时，直接利用session的值来提交到数据库。 同样的用户登录后，回退页面也要用session机制，将用户名和密码存储在其中，过期时间为10分钟。 在注册时发送的验证码应存储在redis数据库中，设置一个过期时间为60s，此时不建议用mysql之类的关系数据库，没必要。 这个预约系统是在档案馆值班的时间做的，挺有收获的，做完了回头看确实很简单，算是对web开发有了初步接触了。 具体代码见https://github.com/agentzxy/reservation-system.git","link":"/2019/12/05/用Flask框架写一个简单的预约系统/"},{"title":"银行排队问题","text":"要解决的问题——银行一天之内的： 1.总客户数 2.客户总逗留时间 3.客户平均逗留时间 银行排队问题可具体化为一个银行、队伍、客户，将客户到达事件、客户离开事件等一系列事件作为事件链表，客户作为链表节点，银行作为一个类。 bank头文件： #include &lt;queue&gt; #include &lt;list&gt; //事件链表 struct Event { int _occur_time;//事件发生时间 int _type;//事件类型，0表示到达事件，1~4表示4个窗口离开事件 }; //银行链表的队伍结点 struct QueueNode { int _arrival_time;//客户到达时间 int _duration_time;//客户在银行待的时间 }; //银行链表 class Bank { public: //防止隐式转化 explicit Bank(int window = 4, int close_time = 8 * 3600); ~Bank(); void Simulation(); private: int _queue_number; //队列个数 int _close_time; //关门时间 int _total_time;//所有客人待的总时间 int _customer_number;//客户数目 std::list&lt;Event&gt; _event_list;//事件链表 std::queue&lt;QueueNode&gt; *_work_queue;//工作队伍队列 void OpenForDay(); void CustomerArrival(Event *event);//客户到达事件 void CustomerDeparture(Event *event);//客户离开事件 int FindShortestQueue(); void SortEventList(); }; bank.cpp: #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &quot;bank.h&quot; #include &lt;clocale&gt; #include &lt;chrono&gt; #include &lt;cstdlib&gt; Bank::Bank(int window, int close_time) :_queue_number(window), _close_time(close_time), _total_time(0), _customer_number(0) { _work_queue = new std::queue&lt;QueueNode&gt;[window];//产生一个新的工作队列 srand(std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()));//产生伪随机序列 } Bank::~Bank() { delete[] _work_queue; } void Bank::OpenForDay() { //第一个客户到达,将第一个客户到达事件压入栈 _event_list.push_back({ 0,0 }); } void Bank::CustomerArrival(Event *event) { ++_customer_number;//客户数加一 int duration_time, inter_time;//inter_time:下一个客户隔多长时间来 duration_time = rand() % 1800 + 1;//一个客户最多30分钟 inter_time = rand() % 600 + 1;//最多10分钟来一个客户 //下一个客户到达时间 int t = event-&gt;_occur_time + inter_time; //假设银行未关门 if (t &lt; _close_time) { _event_list.push_back({ t,0 });//将下一个客户到达事件压栈 SortEventList();//整理、排序事件 } int i; i = FindShortestQueue();//i为最短队列 //将新客户压入最短队列 _work_queue[i].push({ event-&gt;_occur_time,duration_time }); //生成i队列最后一个人的离开事件 if (_work_queue[i].size() == 1) { _event_list.push_back({ event-&gt;_occur_time + duration_time,i + 1 }); SortEventList(); } } void Bank::CustomerDeparture(Event *event) { int i = event-&gt;_type - 1;//i表示1~4哪个队伍离开 QueueNode customer; //客户离开，从队伍中弹出 customer = _work_queue[i].front(); _work_queue[i].pop(); //客户总耗时=之前的耗时+此刻的耗时 _total_time += event-&gt;_occur_time - customer._arrival_time; if (!_work_queue[i].empty()) { customer = _work_queue[i].front(); _event_list.push_back( { customer._duration_time + event-&gt;_occur_time, i + 1 }); SortEventList(); } } int Bank::FindShortestQueue() { int result = 0; for (int i = 0; i &lt; _queue_number; ++i) { if (_work_queue[result].size() &gt; _work_queue[i].size()) result = i; } return result; } void Bank::SortEventList() { // Lambda表达式 _event_list.sort([](const Event &amp;e1, const Event &amp;e2) -&gt; bool {return e1._occur_time &lt; e2._occur_time; }); } //模拟仿真排队 void Bank::Simulation() { OpenForDay(); Event event; while (!_event_list.empty()) { event = _event_list.front(); _event_list.pop_front(); if (event._type == 0) // 到达事件 CustomerArrival(&amp;event); else CustomerDeparture(&amp;event); } // 计算并输出平均逗留时间 std::wcout &lt;&lt; L&quot;客户数：&quot; &lt;&lt; _customer_number &lt;&lt; std::endl &lt;&lt; L&quot;总逗留时间（小时）：&quot; &lt;&lt; (double)_total_time / 3600.0 &lt;&lt; std::endl &lt;&lt; L&quot;平均逗留时间（分钟）：&quot; &lt;&lt; (double)_total_time / (double)(_customer_number * 60) &lt;&lt; std::endl; } int wmain(int argc, wchar_t *argv[], wchar_t *env[]) { _wsetlocale(LC_ALL, L&quot;&quot;); Bank bank; bank.Simulation(); return 0; }","link":"/2019/08/28/银行排队问题/"},{"title":"飞机射击小游戏","text":"fsObject.h: #pragma once #include &lt;iostream&gt; #include &lt;chrono&gt; #ifndef FSOBJECTS_H #define FSOBJECTS_H using namespace std; namespace flightShooting { #define FSOBJECTS_H #define FS_DEFAULT_FIRE_INTERVAL std::chrono::milliseconds(500) // 默认的开火间隔 #define FS_DEFAULT_FRAME_INTERVAL 10 // 默认的刷新频率，即每隔多少毫秒刷新一次 #define FS_DEFAULT_MOVE_STEP 0.01 // 在moveleft()方法和moveright()方法中默认的每次移动距离 #define FS_MOVE_LEFT_KEY &apos;a&apos; // 控制玩家飞机向左移动一个单位所对应的按键 #define FS_MOVE_RIGHT_KEY &apos;d&apos; // 控制玩家飞机向右移动一个单位所对应的按键 #define FS_ESCAPE_KEY &apos; &apos; // 退出游戏所使用的按键 #define FS_DEFAULT_BULLET_FLY_SPEED 3.0 // 默认子弹飞行速度，3代表每秒飞行三个屏幕 #define FS_DEFAULT_AIRCRAFT_FLY_SPEED 0.1 // 默认的飞机飞行速度 #define FS_DEFAULT_BULLET_COLOR fsColor(255,0,0,0) // 默认子弹颜色 #define FS_DEFAULT_BULLET_SIZE 0.1 //默认的子弹正方形边长 #define FS_DEFAULT_BULLET_SIZE_X 0.05 //默认的子弹长方形在x轴方向的长度 #define FS_DEFAULT_BULLET_SIZE_Y 0.1 //默认的子弹长方形在y轴方向的长度 #define FS_DEFAULT_PLAYER_SYMBOL &apos;*&apos; // 默认的玩家的飞机的符号 #define FS_DEFAULT_ENEMY_SYMBOL &apos;+&apos; // 默认的敌人的飞机的符号 #define FS_DEFAULT_BULLET_SYMBOL &apos;o&apos; // 默认的子弹的符号 #define FS_DEFAULT_SCOREBOARD_COLOR fsColor(0,255,0,0) // 默认的计分版颜色 // 默认的边界位置，这些位置主要在move*方法中限制物体不要超出屏幕边界 #define FS_DEFAULT_COORD_LOWER_LIMIT 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_X 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_X 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_Y 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_Y 0.95 // 飞机子弹来源 template&lt;typename T&gt; class fsPoint { public: T x, y; fsPoint() {}; fsPoint(T xval, T yval) :x(xval), y(yval) {}; fsPoint&lt;T&gt; &amp; operator = (const fsPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this; } }; //飞机子弹的来源 enum bulletSource { player = 1, enemy = 2, playerFriend = 3//分别来自玩家、敌方、玩家朋友 }; //子弹射击方向 enum direction { up = 1, down = 2, right = 3, left = 4 }; /*enum symbol { play = FS_DEFAULT_PLAYER_SYMBOL,en= FS_DEFAULT_ENEMY_SYMBOL,bullet=FS_DEFAULT_BULLET_SYMBOL }; */ class fsInvalidInitializePointValException : public std::logic_error { public: fsInvalidInitializePointValException() :std::logic_error(&quot;Invalid initialze fsPoints!&quot;) {}; }; class fsOutRangeMoveToPointException : public std::logic_error { public: fsOutRangeMoveToPointException() : std::logic_error(&quot;the move to point is out of the range of 0 to 1 for either x or y&quot;) {}; }; class fsInvalidFireTimeException :public std::logic_error { public: fsInvalidFireTimeException() :std::logic_error(&quot;Not right time to fire!&quot;) {}; }; class fsInvalidBulletSpeedInException : public std::logic_error { public: fsInvalidBulletSpeedInException() : std::logic_error(&quot;bullet speed in must be a positive number!&quot;) {}; }; class fsColor { public: unsigned char r, g, b, a; //全部为0~255 0 表示完全不透明 fsColor() {}; fsColor(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) : r(red), g(green), b(blue), a(alpha) {}; }; //游戏中所用物体的基类 class fsObject { private: fsPoint&lt;double&gt; upperLeftCorner; // the position fsPoint&lt;double&gt; lowerRightCorner; fsColor foregroundColor; char symbol; int visible; // 物体是否可见，如果为0则不可见 public: fsObject() {}; //物体的位置、颜色、符号 fsObject(const fsPoint&lt;double&gt; &amp;upperleft, const fsPoint&lt;double&gt; &amp;lowerright, const fsColor &amp;fgc, char sym = 0) { if (upperleft.x &gt; lowerright.x || upperleft.y &gt; lowerright.y) throw fsInvalidInitializePointValException(); this-&gt;upperLeftCorner = upperleft; this-&gt;lowerRightCorner = lowerright; this-&gt;foregroundColor = fgc; this-&gt;symbol = sym; this-&gt;visible = 1; } //获得左上角位置 fsPoint&lt;double&gt; getUpperLeftCorner() const { return this-&gt;upperLeftCorner; } //获得右下角位置 fsPoint&lt;double&gt; getLowerRightCorner() const { return this-&gt;lowerRightCorner; } //获得符号 char getSymbol() const { return this-&gt;symbol; } //设置符号 void setSymbol(char c) { this-&gt;symbol = c; } //设置为可见 int getVisible() const { return this-&gt;visible; } //获得是否可见 void setVisible(int newVisible) { this-&gt;visible = newVisible; return; } // 移动位置，向左移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveleft() { if (this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP &lt; 0) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x - FS_DEFAULT_MOVE_STEP; return 1; } // 移动位置，向右移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveright() { if (this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP &gt; 1) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP; return 1; } //检测竖直方向上移位是否正确 int moveVertically(double delta) { if (this-&gt;upperLeftCorner.y + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_UPPER_LIMIT_Y; return 0; } if (this-&gt;upperLeftCorner.y + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_LOWER_LIMIT_Y; return 0; } this-&gt;upperLeftCorner.y = this-&gt;upperLeftCorner.y + delta; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.y + delta; return 1; } //在水平方向上移动位置，如果输入的delta导致物体的左上角超出屏幕，就将其置为最近的FS_DEFAULT_COORD_UPPER_LIMIT_X或FS_DEFAULT_COORD_UPPER_LIMIT_X int moveHorizontally(double delta) { if (this-&gt;upperLeftCorner.x + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_UPPER_LIMIT_X; return 0; } if (this-&gt;upperLeftCorner.x + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_LOWER_LIMIT_X; return 0; } this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + delta; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + delta; return 1; } //将物体的右下角移动到一点 int movePoint(const fsPoint&lt;double&gt; &amp;dest) { if (dest.x &gt; 1 || dest.x &lt; 0 || dest.y &gt;1 || dest.y &lt; 0) { throw fsOutRangeMoveToPointException(); } this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + dest.x - this-&gt;upperLeftCorner.x; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.x + dest.y - this-&gt;upperLeftCorner.y; this-&gt;upperLeftCorner = dest; } void printpos() const { cout &lt;&lt; &quot;ULC:&quot; &lt;&lt; (this-&gt;getLowerRightCorner()).x &lt;&lt; &quot; &quot; &lt;&lt; (this-&gt;getLowerRightCorner()).y &lt;&lt; endl; return; } }; //子弹类 class fsBullet :public fsObject { private: fsObject bullet; bulletSource source; direction bulletDirection; // 飞行方向 double vec; // 飞行速度，目前暂时不允许子弹斜着飞 并且不允许是负数 int bulletDamage; std::chrono::high_resolution_clock::time_point lastPositionUpdateTime; public: fsBullet() {}; fsBullet(bulletSource sourceOfBullet, direction directionOfBullet, int damageOfBullet, fsPoint&lt;double&gt; sourceulc, double bulletVec = FS_DEFAULT_BULLET_FLY_SPEED) : fsObject(sourceulc, fsPoint&lt;double&gt;(sourceulc.x + FS_DEFAULT_BULLET_SIZE_X, sourceulc.y + FS_DEFAULT_BULLET_SIZE_Y), FS_DEFAULT_BULLET_COLOR), source(sourceOfBullet), bulletDirection(directionOfBullet), bulletDamage(damageOfBullet), lastPositionUpdateTime(std::chrono::high_resolution_clock::now()) { if (bulletVec &lt; 0) throw fsInvalidBulletSpeedInException(); this-&gt;vec = bulletVec; if (this-&gt;bulletDirection == up) vec = vec * -1; bullet.setSymbol(FS_DEFAULT_BULLET_SYMBOL); } //更新子弹位置 int updataPosition() { std::chrono::microseconds timeelapsed = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::high_resolution_clock::now() - this-&gt;lastPositionUpdateTime); double delta = 1.0 * timeelapsed.count() / 1000000 * vec; //cout &lt;&lt; &quot;delta&quot; &lt;&lt; delta &lt;&lt; endl; this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); if (bullet.moveVertically(delta) == 0) return 0; return 1; } }; //所有飞机的基类 class fsAircraft :public fsObject { private: chrono::milliseconds fireInterval; // 两发炮弹之间的间隔，单位为ms chrono::steady_clock::time_point lastFireTime; int lifeLeft = 1; // 剩余的生命值 int bulletDamage = 1; // 默认的机体伤害值 bulletSource source; direction bullteDirection; public: fsAircraft() {}; fsAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsObject(upperleft, lowerright, fgc), fireInterval(fireinterval) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); }; inline int fireReady() { if (chrono::high_resolution_clock::now() - this-&gt;lastFireTime &gt; fireInterval) { return 1; } return 0; } // 强制发射子弹，返回fsBullet的对象，即该飞机所发射的子弹 fsBullet fire() { //if (fireReady()) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); return fsBullet(this-&gt;source, this-&gt;bullteDirection, this-&gt;bulletDamage, this-&gt;getUpperLeftCorner()); //} //throw fsInvalidFireTimeException(); } int setBullteDamage(int newBulletDamage) { this-&gt;bulletDamage = newBulletDamage; return 0; } // 设置飞机是玩家的飞机还是敌人的飞机 void setSource(bulletSource newSource) { this-&gt;source = newSource; } // 设置新的子弹飞行方向 void setFireDirection(direction newDirection) { this-&gt;bullteDirection = newDirection; } //返回剩余生命值，当返回0或者负数时说明死亡（本程序中没有使用） int getLifeLeft() const { return this-&gt;lifeLeft; } int gotHit(int bulletDamage = 1) { if (this-&gt;lifeLeft - bulletDamage &lt;= 0) { this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; return 0; } this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; } }; //玩家的飞机 class fsMyAircraft :public fsAircraft { public: fsMyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，发射子弹后，再经过此段时间后才能再次发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(player); this-&gt;setFireDirection(up); this-&gt;setSymbol(FS_DEFAULT_PLAYER_SYMBOL); }; }; //敌方的飞机 class fsEnemyAircraft : public fsAircraft { private: std::chrono::high_resolution_clock::time_point lastPositionUpdateTime; // 最后一次更新物体位置的时间 std::chrono::high_resolution_clock::time_point lastDirectionUpdateTime; // 最后一次更新运动方向的时间 double vec; // 飞行速度，指在水平方向上的飞行速度 std::chrono::milliseconds directionUpdateInterval; // 两次速度方向更新之间的时间间隔，最好能用随机数产生 public: fsEnemyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(enemy); this-&gt;setFireDirection(down); this-&gt;setSymbol(FS_DEFAULT_ENEMY_SYMBOL); this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;directionUpdateInterval = std::chrono::milliseconds(1000); this-&gt;vec = FS_DEFAULT_AIRCRAFT_FLY_SPEED; } // 更新敌机的位置，敌机随机移动，每隔一段时间更换一个方向，移动会在一个矩形框中进行 int updatePosition() { // 是否要更换方向 if (std::chrono::high_resolution_clock::now() - lastDirectionUpdateTime &gt; directionUpdateInterval) { //产生一个新的方向 lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;vec = this-&gt;vec * (-1); srand((unsigned)time(NULL)); directionUpdateInterval = std::chrono::milliseconds(rand() / 5 + 1000); // 随机数的范围在1s到7s之间 } std::chrono::milliseconds elapsedtime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - lastPositionUpdateTime); lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;moveHorizontally(1.0 * elapsedtime.count() / 1000 * vec); return 0; } }; // 计分版 用于记录玩家的分数 class fsScoreBoard : public fsObject { private: int score = 0; // 每次击中算一分 public: fsScoreBoard() {}; fsScoreBoard(const fsPoint&lt;double&gt; &amp; upperleft, // 计分版左上角的位置 推荐将左上角的横坐标设置为大于1的数，避免分数的显示与游戏画面重叠 const fsPoint&lt;double&gt; &amp; lowerright, // 计分版右下角的位置 const fsColor &amp; fgc = FS_DEFAULT_SCOREBOARD_COLOR // 计分版颜色，在控制台情况下无效 ) :fsObject(upperleft, lowerright, fgc) { ; } // 获取计分版分数 int getCurScore() const { return this-&gt;score; } // 增加得分 void addScore(int delta = 1) { this-&gt;score = this-&gt;score + 1; } }; // 判断两个物体是否重叠 如果重叠将返回1 否则返回0，主要用来判定子弹是否击中了飞机 int fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) ; // 判断一个点是否在一个矩形中，包括在矩形边上的情况 template &lt;typename T&gt; bool fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight); int fsInitialize(); //int fsGameLoop(); } #endiffsDraw.h： #pragma once #include &quot;fsObject.h&quot; #include &lt;Windows.h&gt; #include &lt;conio.h&gt; #ifndef FSDRAW_H #define FSDRAW_H using namespace flightShooting; using namespace std; namespace flightShooting { #define FS_DEFAULT_CONSOLE_BUFFER_SCALE 50 //光标位置 void gotoxy(int x, int y) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(consoleBuf, pos); } //设置颜色 void setcolor(WORD color) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color); } void setcolor(WORD color, HANDLE consoleBuf) { SetConsoleTextAttribute(consoleBuf, color); } //画出对象 int fsDraw(const fsObject &amp; fso) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED); cout &lt;&lt; fso.getSymbol(); return 0; } int fsDraw(const fsObject &amp; fso, HANDLE consoleBuf) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED, consoleBuf); cout &lt;&lt; fso.getSymbol(); return 0; } //画出计分板 int fsDrawScoreBoard(const fsScoreBoard &amp;fsb) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_GREEN); cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore(); return 0; } int fsDrawScoreBoard(const fsScoreBoard &amp; fsb, HANDLE consoleBuf) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_GREEN, consoleBuf); cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore(); return 0; } // 用空格填充控制台的缓存 int fsFillWithBlank() { gotoxy(0, 0); for (int i = 0; i &lt; 1000 * 1000; ++i) { cout &lt;&lt; &quot; &quot;; } return 0; } } #endiftest.h: int gameTestOneBuf() { // 初始化玩家飞机 fsMyAircraft playerAircraft = fsMyAircraft(fsPoint&lt;double&gt;(0.5, 0.99), fsPoint&lt;double&gt;(0.51, 1.00), fsColor(255, 255, 255, 0)); // 初始化敌方飞机 fsEnemyAircraft enemy1 = fsEnemyAircraft(fsPoint&lt;double&gt;(0.5, 0.10), fsPoint&lt;double&gt;(0.51, 0.11), fsColor(255, 0, 0, 0)); // 初始化计分板 fsScoreBoard scoreBoard = fsScoreBoard(fsPoint&lt;double&gt;(1.1, 0.3), fsPoint&lt;double&gt;(1.11, 0.31)); // 等待1s以便能够通过fire函数成功初始化子弹 Sleep(1000); fsBullet mybullet; if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } fsBullet enemybullet; if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } // 初始化键盘按键存储变量 char ch = &apos;/0&apos;; // 游戏循环 while (1) { // 获取按键 if (_kbhit()) { ch =_getche(); } // 依据不同的按键做出对应的反应 switch (ch) { case FS_MOVE_LEFT_KEY: playerAircraft.moveleft(); break; case FS_MOVE_RIGHT_KEY: playerAircraft.moveright(); break; case FS_ESCAPE_KEY: cout &lt;&lt; &quot;You ended this game!&quot;; return 0; default: break; } ch = 0; // 更新各对象的状态 if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } mybullet.updataPosition(); enemybullet.updataPosition(); enemy1.updatePosition(); // 呈现图像 system(&quot;cls&quot;); fsDraw(playerAircraft); fsDraw(mybullet); fsDraw(enemy1); fsDraw(enemybullet); fsDrawScoreBoard(scoreBoard); // 子弹击中的判定，如果子弹击中，则将原来的子弹设为不可见 if (fsOverlap(mybullet, enemy1)) { scoreBoard.addScore(); mybullet.setVisible(0); } if (fsOverlap(enemybullet, playerAircraft)) { cout &lt;&lt; &quot;you are hit!&quot;; enemybullet.setVisible(0); Sleep(500); } Sleep(FS_DEFAULT_FRAME_INTERVAL); } return 0; }fsObject.cpp: #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &lt;iostream&gt; #include &lt;Windows.h&gt; #include &lt;chrono&gt; #include &lt;vector&gt; #include &lt;conio.h&gt; #include &quot;fsObject.h&quot; using namespace std; using namespace flightShooting; int flightShooting::fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) { if (obj1.getVisible() == 0 || obj2.getVisible() == 0) return 0; // 重叠判定要稍微费点脑筋 // 判断矩形是否重叠，只需要对每个矩形，分别判断其四个顶点是否在另外一个矩形内 const fsPoint&lt;double&gt; obj1ulc = obj1.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj1lrc = obj1.getLowerRightCorner(); const fsPoint&lt;double&gt; obj1urc = fsPoint&lt;double&gt;(obj1lrc.x, obj1ulc.y); const fsPoint&lt;double&gt; obj1llc = fsPoint&lt;double&gt;(obj1ulc.x, obj1lrc.y); const fsPoint&lt;double&gt; obj2ulc = obj2.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj2lrc = obj2.getLowerRightCorner(); const fsPoint&lt;double&gt; obj2urc = fsPoint&lt;double&gt;(obj2lrc.x, obj2ulc.y); const fsPoint&lt;double&gt; obj2llc = fsPoint&lt;double&gt;(obj2ulc.x, obj2lrc.y); // bool test = fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj1InObj2 = fsPointInRect(obj1ulc, obj2ulc, obj2lrc) || fsPointInRect(obj1urc, obj2ulc, obj2lrc) || fsPointInRect(obj1llc, obj2ulc, obj2lrc) || fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj2InObj1 = fsPointInRect(obj2ulc, obj1ulc, obj1lrc) || fsPointInRect(obj2urc, obj1ulc, obj1lrc) || fsPointInRect(obj2llc, obj1ulc, obj1lrc) || fsPointInRect(obj2lrc, obj1ulc, obj1lrc); return obj1InObj2 || obj2InObj1; } template&lt;typename T&gt; bool flightShooting::fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight) { return (point.x &gt;= RectUpperLeft.x &amp;&amp; point.x &lt;= RectLowerRight.x) &amp;&amp; (point.y &gt;= RectUpperLeft.y &amp;&amp; point.y &lt;= RectLowerRight.y); }fsTest.cpp: #include &lt;iostream&gt; #include &quot;pch.h&quot; #include &quot;fsObject.h&quot; #include &quot;fsTest.h&quot; using namespace std; using namespace flightShooting; int main() { gameTestOneBuf(); return 0;}","link":"/2019/08/31/飞机射击小游戏-1/"},{"title":"递归问题","text":"最近数据结构刚刚学了递归问题，感觉理解的不太到位，刚好leetcode刷题刷到了两个递归问题，对递归算是更进一步理解了吧。 leetcode—22.括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 当加入一个左括号时，剩余的可看作新的组合，但右括号的个数必须大于左括号的个数时，才表明可以加入右括号，C++代码如下： vector&lt;string&gt; res; void back(string s,int i,int j){ int n; if(i==0&amp;&amp;j==0) { res.push_back(s); return; } if(i&gt;0) back(s+&apos;(&apos;,i-1,j); if(j&gt;i) back(s+&apos;)&apos;,i,j-1); } vector&lt;string&gt; generateParenthesis(int n) { back(&quot;&quot;,n,n); return res; }leetcode—39.组合总数 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 利用递归求解，将数组中的第一个数提取出来，则可以看作是求candidates中所有可以使数字和为（target-第一个数字）的组合，以此类推，但必须注意不能有重复的组合，所以应该在后面的数被提取时，不能与前面的数相匹配。C++代码如下： vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { com(0,candidates,target); return res; } void com(int cur,vector&lt;int&gt;&amp; candidates,int target) { int t; t=target; for(int i=cur;i&lt;candidates.size();i++) { if(target==0) { res.push_back(tmp); return; } if(target&gt;0) { tmp.push_back(candidates[i]); com(i,candidates,target-candidates[i]); tmp.pop_back(); } else continue; target=t; } }","link":"/2019/06/02/递归问题/"},{"title":"自制简单操作系统（3）","text":"今天主要是实现鼠标的移动，昨天写的是中断后直接跳转到中断处理程序，处理过程也在那个函数里面。今天改良了，使用缓冲区来实现（其实就是栈）,比如键盘按下一个键后，将发送的字节送入缓冲区，然后在主函数里面，读出存储的字节，这样就可以实现不停的按下键，并且读入字节。利用结构体实现一个缓冲区。 鼠标移动就会发送出三个字节，第一个字节是点击和移动鼠标的，第二个字节是x值，第三个是y值（位置），也可以将鼠标发送的字节存储在缓冲区内，然后读出。利用读出的xy值将鼠标隐藏，然后重新绘制鼠标。 当鼠标一移动，就会发出中断，因为先前设置了鼠标的中断号码和响应函数，即可响应中断，但其实我不太明白GDT为什么要初始化。 里面还涉及到鼠标和键盘的控制电路的初始化，激活鼠标，因为键盘控制电路中含有鼠标控制电路，所以获取鼠标发送的字节和键盘一样。 关于控制电路初始化那块不太明白，感觉鼠标移动还是很好理解的。 成果图：","link":"/2019/12/09/制简单操作系统（3）/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"},{"name":"c++","slug":"c","link":"/categories/c/"}]}