{"pages":[],"posts":[{"title":"Ananagrams-Uva 156","text":"输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文 本中的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中 的大小写，按字典序进行排列（所有大写字母在所有小写字母的前面）。 样例输入： ladder came tape soon leader acme RIDE lone Dreis peat ScAlE orb eye Rides dealer NotE derail LaCeS drIednoel dire Disk mace Rob dries 样例输出： Disk NotE derail drIed eye ladder soon 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;string change(string s){ string s1=\"\"; for (int i = 0; i &lt; s.length(); i++) { s1+= tolower(s[i]); } sort(s1.begin(),s1.end()); return s1;}int main(){ string s; int i = 0, j = 0; vector&lt;string&gt; vec; vec.push_back(\"\"); getline(cin, s); while (true) { if (s[j] == '#') break; else if (s[j] == ' ') { i++; vec.push_back(\"\"); } else vec[i] += s[j]; j++; } map&lt;string, int&gt; m; vector&lt;string&gt; out; int count = vec.size(); for (i = 0; i &lt; count; i++) { string r = change(vec[i]); if (m.count(r)) { m[r] = 1; } m.insert(pair&lt;string, int&gt;(r, 0)); } for (i = 0; i &lt; vec.size(); i++) { if (m[change(vec[i])] == 0) { out.push_back(vec[i]); } } sort(out.begin(), out.end()); for (i = 0; i &lt; out.size(); i++) cout &lt;&lt; out[i] &lt;&lt; endl; return 0;}","link":"/2020/01/11/TL相关题/"},{"title":"OS-汇编学习和Makefile入门","text":"我是跟着川合秀实的《30天自制操作系统》做的，感觉这本书挺好的，比较易懂，打算在博客记录下我的学习过程。 主要是用C语言写，有些C语言没有的功能，比如HLT指令之类的，就需要用汇编嵌入C语言中。 首先制作启动区，0x7c00-0x7dff用于启动区，写一个汇编语言程序，并且将它转成机器语言。主要功能是能读取软盘的10个柱面（当然我并没有买软盘，是用的作者提供的一个模拟器），如果读取错误则显示出error。 接着开始写程序。使用C语言编写，里面有整个操作系统颜色定义，现在只定义了16种颜色，但足够了，将颜色读入显卡的内存地址，BIOS里面定义VRAM（显卡内存）是0xa0000-0xaffff的64KB，依次读入就可以了。里面有的中断设置和使CPU休眠的HLT指令要利用汇编完成。 C语言编写后将其转成nas文件（作者自己命名的，相当于汇编语言文件），然后再将nas文件转为机器语言即可。 为了不会出现很多批处理文件，使用了Makefile，在makefile文件里面执行命令，将nas文件转成bin文件，将C的源文件转成gas，把gas再转为nas文件，nas转obj目标文件，接着就可以转二进制映像了。 nas文件用nask编译后可输出sys文件，将sys文件与做成的映像文件作比较可以发现，一般向一个空软盘保存文件时，文件名会写在0x002600以后的地方，文件内容会写在0x004200以后的地方（我觉得的也就是程序的意思）. 成果：","link":"/2019/12/07/制简单操作系统（1）-1/"},{"title":"java小作业-简单计算器","text":"java课上老师布置的小作业，一个简单计算器的实现，挺简单的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.company;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.lang.String;import java.util.Stack;public class GridL extends JFrame{static Font ff=new Font(\"幼圆\",Font.BOLD,30);public GridL(String title) { super(title); setLayout(new BorderLayout()); JPanel p=new JPanel(); TextField t=new TextField(300); add(\"North\",t); add(p); GridLayout g=new GridLayout(4, 4); p.setLayout(g); for (int i = 1; i &lt;= 3; i++) { JButton b2 = new JButton(i+\"\"); String input=i+\"\"; //result=i; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+input); } }); p.add(b2); b2.setFont(ff); } JButton b1 = new JButton(\"-\"); b1.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+\"-\"); } }); p.add(b1); b1.setFont(ff); for (int i = 4; i &lt;= 6; i++){ JButton b2 = new JButton(i+\"\"); String input=i+\"\"; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s = t.getText(); t.setText(s + input); } }); p.add(b2); b2.setFont(ff); } JButton b3 = new JButton(\"+\"); b3.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+\"+\"); } }); p.add(b3); b3.setFont(ff); for (int i = 7; i &lt;= 9; i++) { JButton b2 = new JButton(i + \"\"); String input = i + \"\"; b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s = t.getText(); t.setText(s + input); } }); p.add(b2); b2.setFont(ff); } JButton b4 = new JButton(\"*\"); b4.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+\"*\"); } }); b4.setFont(ff); p.add(b4); JButton b5 = new JButton(\".\"); b5.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+\".\"); } }); b5.setFont(ff); p.add(b5); JButton b6 = new JButton(\"*\"); b6.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+\"0\"); } }); b6.setFont(ff); p.add(b6); JButton b7 = new JButton(\"=\"); b7.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); int result=0; Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); stack.push((int) (s.charAt(0)-'0')); for(int i=1;i&lt;s.length()-1;i++) { char ch = s.charAt(i); if (ch == '+') { stack.push((int) (s.charAt(i + 1) - '0')); } else if (ch == '-') { stack.push((int) -1 * (s.charAt(i + 1) - '0')); } else if (ch == '*') { int num = stack.peek(); stack.pop(); stack.push((int) num * (s.charAt(i + 1) - '0')); } else if (ch == '/') { int num = stack.peek(); stack.pop(); stack.push((int) num / (s.charAt(i + 1) - '0')); } } while(!stack.empty()){ result=result+stack.peek(); stack.pop(); } t.setText(result+\"\"); } }); b7.setFont(ff); p.add(b7); JButton b8 = new JButton(\"/\"); b8.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String s=t.getText(); t.setText(s+\"/\"); } }); b8.setFont(ff); p.add(b8); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);}public static void main(String[] args) { GridL frm=new GridL(\"计算器\"); frm.setSize(300,350); frm.setVisible(true);}} 界面也很简单： 大二刚转专业时有一门课叫做程序设计上机实践，是利用C#来写，第一个小作业就是实现一个简单计算器。当时刚转专业，除了大一学习的C++，之前也没怎么接触过计算机。所以开始看见这个项目是一脸懵逼的，全程都是抄的别人的，看也看不懂。 一年过去了，现在大三，还是很菜鸡，但比起大二刚转专业算是入门了吧。整个大二都在学习中度过，因为大二上学期成绩下滑厉害，所以即便是下学期拼命追赶也无法保研，真的很多情绪只能自己体会。现在也放弃保研了，要准备考研，但不后悔大二做的一切。 哈哈哈，做完这个小作业后有感而发","link":"/2019/12/06/ava小作业-简单计算器/"},{"title":"OS-中断制作","text":"今天主要是学习中断处理程序的制作，以键盘和鼠标为例，键盘输入后，CPU进行中断处理。 GDT是记录段号的，一共64KB，每个段分配8个字节，用20位记录段大小。32位记录段起始地址，12位记录段的管理信息。然后进行初始化。 PIC是可编程中断控制器，一般来说CPU只能单独的处理一个中断，PIC将8个中断信号集合成一个，PIC分为主PIC和从PIC，从PIC连接到主PIC的一个端口。首先要将PIC初始化，将主从PIC全部禁止、ICW的初始化，其中可以利用ICW2来使PIC设定中断号，例如主PIC的0-7端口由INT20-INT27来接收。 IDT是记录0-255的中断号码与调用函数的关系。同理将IDT初始化，IDT中记录了把一个中断后执行的程序注册到IDT的多少号、中断执行、管理信息。 写一个函数将鼠标和键盘中断的GDT和IDT初始化，将每段的信息利用for循环存入GDT中，再将键盘和鼠标注册到IDT的第21和2c号。如果发生中断，CPU就自动调用利用汇编编写的相应的中断处理函数。 在主函数中，允许键盘中断和鼠标终端，具体就是将值送到PIC的主从端口，设定中断号，这样一旦有键按下，就会触发中断执行，然后由于键盘在IDT中注册了中断号，所以就会触发程序执行。 成果图如下： 但鼠标不知道为什么不能执行中断。 上面讲的肯定有很多不对的地方，也有一些地方是模糊的，继续往后做，我觉得肯定能越来越明白的。","link":"/2019/12/08/制简单操作系统（2）/"},{"title":"The Set Stack Computer-Uva 12096","text":"有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且 支持以下操作。 PUSH：空集“{}”入栈。 DUP：把当前栈顶元素复制一份后再入栈。 UNION：出栈两个集合，然后把二者的并集入栈。 INTERSECT：出栈两个集合，然后把二者的交集入栈。 ADD：出栈两个集合，然后把先出栈的集合加入到后出栈的集合中，把结果入栈。 每次操作后，输出栈顶集合的大小（即元素个数）。 输入不超过2000个操作，并且保证操作均能顺利进行（不需要对空栈执行出栈操作）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;map&lt;set&lt;int&gt;, int&gt; idcache;vector&lt;set&lt;int&gt;&gt; setcache;int getid(set&lt;int&gt; s) { if (idcache.count(s)) return idcache[s]; setcache.push_back(s); idcache[s] = setcache.size() - 1; return idcache[s];}int main() { int count; cin &gt;&gt; count; while (count--) { stack&lt;int&gt; s; idcache.clear(); setcache.clear(); int n; cin &gt;&gt; n; while (n--) { string str; cin &gt;&gt; str; if (str == \"PUSH\") { set&lt;int&gt; temp; //setcache.push_back(temp); s.push(getid(temp)); } else if (str == \"DUP\") { s.push(s.top()); } else { set&lt;int&gt; first = setcache[s.top()]; s.pop(); set&lt;int&gt; second = setcache[s.top()]; s.pop(); set&lt;int&gt; ans; if (str == \"ADD\") { ans = second; ans.insert(getid(first)); } if (str == \"INTERSECT\") { set&lt;int&gt;::iterator it_f = first.begin(); for (; it_f != first.end(); it_f++) { set&lt;int&gt;::iterator it_s = second.begin(); for (; it_s != second.end(); it_s++) { if (*it_f == *it_s) { ans.insert(*it_f); } } } } if (str == \"UNION\") { ans = second; set&lt;int&gt;::iterator it_f = first.begin(); for (; it_f != first.end(); it_f++) { ans.insert(*it_f); } } s.push(getid(ans)); } cout &lt;&lt; setcache[s.top()].size() &lt;&lt; endl; } return 0; }}","link":"/2020/01/11/The-Set-Stack-Computer-Uva-12096/"},{"title":"Trees on the level-UVa 122","text":"树和队列的应用 输入一棵二叉树，你的任务是按从上到下、从左到右的顺序输出各个结点的值。 每个结 点都按照从根结点到它的移动序列给出（L表示左，R表示右）。 在输入中，每个结点的左 括号和右括号之间没有空格，相邻结点之间用一个空格隔开。每棵树的输入用一对空括 号“()”结束（这对括号本身不代表一个结点），如图6-3所示。 (具体参见Uva-122) 注意，如果从根到某个叶结点的路径上有的结点没有在输入中给出，或者给出超过一 次，应当输出-1。结点个数不超过256。 样例输入： (11,LL) (7,LLL) (8,R) (5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) () (3,L) (4,R) () 样例输出： 5 4 8 11 13 4 7 2 1 -1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;struct Node { bool have_value; int v; Node* left, * right; Node() :have_value(false), left(NULL), right(NULL){}};bool failed;Node* root;Node* newnode() { return new Node(); }queue&lt;Node*&gt; q;void addnode(int v, string s) { int n = s.length(); Node* u = root; for (int i = 0; i &lt; n; i++) { if (s[i] == 'L') { if (u-&gt;left == NULL) u-&gt;left = newnode(); u = u-&gt;left; } if (s[i] == 'R') { if (u-&gt;right == NULL) u-&gt;right = newnode(); u = u-&gt;right; } } if (u-&gt;have_value) failed = true; u-&gt;v = v; u-&gt;have_value = true;}int main() { string str; cin &gt;&gt; str; root = newnode(); int i = 0; while (true) { string s = \"\"; int j = 0; int v = 0; if (str[i] == '(' &amp;&amp; str[i + 1] == ')') { break; } else if (str[i] == '(') { i++; while (str[i] != ',') { v += int(str[i] - '0') * pow(10, j); j++; i++; } int t = i; i++; while (str[t] == ',') { if (str[i] == ')') break; s += str[i]; i++; } addnode(v, s); } i++; } Node* ans = root; Node* temp; vector&lt;int&gt; vec; q.push(ans); while (!q.empty()) { temp = q.front(); vec.push_back(temp-&gt;v); q.pop(); if (temp-&gt;left != NULL) { ans = temp-&gt;left; q.push(ans); } if (temp-&gt;right != NULL) { ans = temp-&gt;right; q.push(ans); } } for (vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); it++) { cout &lt;&lt; *it &lt;&lt; endl; } return 0;}","link":"/2020/01/13/rees-on-the-level-UVa-122/"},{"title":"OS-图层制作","text":"这次增加了图层的应用，用来进行画面的叠加处理。同样也是利用结构体完成，SHEET结构体记录每个图层的信息，SHTCTL结构体记录了所有图层的信息。然后首先给每个图层分配相应的内存空间。将图层的显示顺序从次到主依次排序，显示越底层的，内存分配的起始地址越小。接着将每个图层绘制处理，每个图层都有自己的显示buf，将其在整个显示屏上绘制出来。鼠标一移动，就要刷新图层，重新绘制所有图层。也正因为这样，让鼠标动得有点一闪一闪的，所以还得优化一下，明天做优化内容。 成果图如下： 由于图层分配了内存，所以可用内存又减少了。","link":"/2019/12/13/制简单操作系统（5）/"},{"title":"枚举排列","text":"枚举排列就是全排列，利用递归实现。比如实现将一个数组里的数全排列： #include&lt;iostream&gt; using namespace std; int p[4] = { 1,2,2,4 }; int a[4]; void pailie(int l, int r, int a[4]) { **//数组a[]是装入排列好的数 //l是当前数组a[]要装入数的下标 //r是数组p[]的元素个数** if (l==r) { **//如果l==r则表明已经完成一次排列，输出即可** for (int m = 0; m &lt; r; m++) { cout &lt;&lt; a[m] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } else { for (int i = 0; i &lt; r; i++) { **//i表示要装入数组a[]中元素的下标** if (i == 0 || p[i] != p[i - 1]) { **//防止p[]中出现两种相同元素的数组，重复排列** int c1 = 0, c2 = 0; for (int m = 0; m &lt; r; m++) { **//c1表示数组p中，与正在进行排列的数相同的数有多少** if (p[m] == p[i]) c1++; } for (int n = 0; n &lt; l; n++) { **//c1表示数组a中，与正在进行排列的数相同的数有多少** if (a[n] == p[i]) c2++; } if (c2 &lt; c1) { **//如果a重复的数&lt;p中重复的，则还可以继续排列** a[l] = p[i];**//将该数放入a中** pailie(l + 1, r, a);**//将剩余的数字再次进行全排列** } **//如果a重复的数&gt;p中重复的,则返回到上一层，将此时进行全排列的数的第一个换掉**(i+1) } } } } int main() { pailie(0, 4, a); return 0; }","link":"/2020/01/16/枚举排列/"},{"title":"scrapy框架爬取豆瓣电影top250","text":"在items里主要有五个item：序号、电影名字、电影标签、评分、图片url 由于只爬取了电影，所以movie.py里只有电影这一个spider。里面的parse函数利用xpath将搜索出来的数据导入items里的各个item的列表中，具体代码如下： 123456789101112def parse(self, response): html=response.text html=etree.HTML(html) order=html.xpath('//ol[@class=\"grid_view\"]/li/div/div/em')#序号 title=html.xpath('//ol[@class=\"grid_view\"]/li/div/div[@class=\"pic\"]/a/img/@alt') inq=html.xpath('//ol[@class=\"grid_view\"]/li/div/div[@class=\"info\"]/div[@class=\"bd\"]/p[@class=\"quote\"]/span') rating_num=html.xpath('//ol[@class=\"grid_view\"]/li/div/div[@class=\"info\"]/div[@class=\"bd\"]/div/span[@class=\"rating_num\"]') image_url=html.xpath('//ol[@class=\"grid_view\"]/li/div/div[@class=\"pic\"]/a/img/@src') item=movieItem() item['nums']=order item['names']=title item['tags']=inq item['scores']=rating_num item['images']=image_url yield item 注意一定要yield item，不然无法对items里面的进行数据处理 然后就是利用pipeline对数据处理，分为三个，分别是原始的、传入mysql的、将剧照保存的。 传入mysql： def process_item(self,item,spider): for i in range(24): sql=\"INSERT INTO top250(NUM,NAME,TAG,SCORE) VALUES(%s,%s,%s,%s)\" num=item['nums'][i].text name=item['names'][i] tag=item['tags'][i].text score=item['scores'][i].text s=(num,name,tag,score) self.cursor.execute(sql,s) self.db.commit() return item 保存图片的： def process_item(self,item,spider): for i in range(24): splitPath=item['images'][i].split('.') fTail=splitPath.pop() fileName=item['names'][i]+\".\"+fTail filepath=\"D:/ddddd/\"+fileName request.urlretrieve(item['images'][i],filepath) 最后就是在settings里面设置一些参数，具体代码参见github","link":"/2019/11/14/crapy框架爬取豆瓣电影top250/"},{"title":"OS-图层应用","text":"这次主要是将鼠标移动优化和做出一个计时器的窗口。 之前由于每移动一次鼠标就需要将整个画面重新绘制，导致鼠标不太灵敏，画面有些一顿一顿。为了优化鼠标移动，我们将绘制整个画面缩小为只绘制移动的画面。写三个函数，分别是刷新整个画面的某一部分、刷新一个图层的某一部分、有移动后刷新，依次调用上一个函数即可。 计时器就是显示数字，不断地for循环。难点是每次刷新时总是先要绘制背景，才能显示数字，所以每次显示数字前会有背景色覆盖。所以这里引入了map，主要是记录每个像素点属于哪一个图层，重新绘制时只需要绘制指定的图层即可。具体做法是在绘制每一层图层时，如果map记录的是该图层，就可以绘制。 下面总结一下图层的应用： 分别由两个结构体SHEET和SHTCTL，SHEET是记录每个图层的信息，参数有该图层的每个像素点的地址、图层长宽、图层位置、图层透明度、图层高度（高度越高，显示越靠前）、是否可见、该图层所属的图层体。SHTCTL我将它成为图层体，图层体里有很多图层，参数有图层体大小、图层体里的图层最高高度、数组记录每个图层位置、每个图层。 首先将图层图层体初始化，在内存中分配地址，再将图层体分配给一个个图层并且初始化。如果有移动，则重新绘制移动部分的该图层。图层不要了就要释放所占的内存。 成果图如下：","link":"/2019/12/16/制简单操作系统（6）/"},{"title":"OS-鼠标移动(1)","text":"今天主要是实现鼠标的移动，昨天写的是中断后直接跳转到中断处理程序，处理过程也在那个函数里面。今天改良了，使用缓冲区来实现（其实就是栈）,比如键盘按下一个键后，将发送的字节送入缓冲区，然后在主函数里面，读出存储的字节，这样就可以实现不停的按下键，并且读入字节。利用结构体实现一个缓冲区。 鼠标移动就会发送出三个字节，第一个字节是点击和移动鼠标的，第二个字节是x值，第三个是y值（位置），也可以将鼠标发送的字节存储在缓冲区内，然后读出。利用读出的xy值将鼠标隐藏，然后重新绘制鼠标。 当鼠标一移动，就会发出中断，因为先前设置了鼠标的中断号码和响应函数，即可响应中断，但其实我不太明白GDT为什么要初始化。 里面还涉及到鼠标和键盘的控制电路的初始化，激活鼠标，因为键盘控制电路中含有鼠标控制电路，所以获取鼠标发送的字节和键盘一样。 关于控制电路初始化那块不太明白，感觉鼠标移动还是很好理解的。 成果图：","link":"/2019/12/09/制简单操作系统（3）/"},{"title":"OS-多任务处理(1)","text":"由于考试，已经将近一个月没碰操作系统了，今天继续。 今天主要做的是多任务的切换。同样的也要用到定时器，定时器确实万能。首先是定义一个任务结构体，里面有定义了任务所需的26个成员。其中常用的有eip、esp。eip用来记录CPU下一条需要执行的指令存放位置。esp是该任务的堆栈。 先定义任务A和任务B这两个任务，并且将任务分别加入GDT中，任务A是3号，任务B是4号。 接着设置0.02s的定时器，规定每0.02秒切换任务。切换任务很简单，直接JMP到任务的位置就可以了。 为了使系统更稳定，在检查超时计时器的程序当中加入一段程序：如果是0.02秒的超时了，则转入一个任务切换函数。该任务切换函数是如果目前任务是A则jmp到任务B（jmp利用汇编完成）。如果是直接在主函数里面进行跳转到另一个任务，然后再在另一个任务跳转到原始任务，那么要是另一个任务出现问题，则系统会无法运行其他程序。","link":"/2020/01/14/制简单操作系统（9）/"},{"title":"OS-内存管理","text":"今天学习的是内存管理。首先是内存检查，把值写入内存再反转，观察值是否改变，若没变就代表内存没问题，利用for循环将每个内存地址都写入值。 然后是内存管理，本系统采用的是将每个空闲内存的起始地址和空闲大小记录下来，可以利用结构体来完成。再用一个结构体记录所有空闲内存的情况，然后进行初始化、内存分配和释放内存。采用这种方式记录内存使用情况只用消耗32KB的内存，所以是不错的。 成果图如下：","link":"/2019/12/11/制简单操作系统（4）/"},{"title":"利用Flask框架写一个简单的预约系统","text":"主要功能就是用户登录、管理员登录、利用邮箱注册、增加或取消个人或团体预约记录。系统不难做，但有时候有些点会卡着你一个多小时。 登录是通过查询数据库的结果为1来验证。注册邮箱时碰到一个问题卡了我很久，因为我发送验证码和注册两个都是提交到同一个页面，当注册submit时，由于前面发送验证码已经submit，所以此时填写的email等信息会为空，所以我利用了session机制，如果页面接收到的email等信息不为空，则将其加入session，等到为空时，直接利用session的值来提交到数据库。 同样的用户登录后，回退页面也要用session机制，将用户名和密码存储在其中，过期时间为10分钟。 在注册时发送的验证码应存储在redis数据库中，设置一个过期时间为60s，此时不建议用mysql之类的关系数据库，没必要。 这个预约系统是在档案馆值班的时间做的，挺有收获的，做完了回头看确实很简单，算是对web开发有了初步接触了。 具体代码见https://github.com/agentzxy/reservation-system.git","link":"/2019/12/05/用Flask框架写一个简单的预约系统/"},{"title":"控制台实现贪吃蛇","text":"1.首先要有定义坐标的类，坐标类里参数包括(x,y)。 2.其次定义snake类。用蛇身各点坐标描述蛇的位置，可将蛇的位置分为蛇头和蛇身来描述，蛇头为一个坐标点，使用#表示，蛇身为一个数组，数组各值表示蛇身各点位置。再定义几个成员函数，包括蛇的上下左右移动、蛇吃到食物后变长、蛇直径前行、判断蛇是否出边界或撞向自己、蛇是否吃到食物、显示蛇的图案。 3.然后定义一些函数。有界面上围墙的形成、光标的移动、食物的随机产生。 4.最后通过主函数的调用实现。 cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338 #include \"pch.h\" #include &lt;iostream&gt; #include &lt;Windows.h&gt; #define n 20 #include &lt;conio.h&gt; #include&lt;time.h&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include \"stdlib.h\" using namespace std; //控制光标 void gotoxy(int x, int y) {COORD pos;pos.X = x;pos.Y = y;SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) {COORD pos;pos.X = x;pos.Y = y;SetConsoleCursorPosition(consoleBuf, pos); } //坐标类 template&lt;typename T&gt; class sPoint { public:T x, y;sPoint() {};sPoint(T xval, T yval) :x(xval), y(yval) {};sPoint&lt;T&gt; &amp; operator = (const sPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this;} }; //方向 enum Direction {left='a',right='d' }; //随机产生一个食物 double * setFood() {double *a=new double[2];int x, y;srand(time(0));//随机种子do { x = rand() % 50 + 1; y = rand() % 30 + 1; break;} while (1);gotoxy(x, y);a[0] = x;a[1] = y;//将生成的食物坐标存储起来std::cout &lt;&lt; '0' ;return a; }//生成围墙void getWall(){ sPoint&lt;double&gt; wall; wall.x = 0; wall.y =0; while (wall.y &lt;= 30) { gotoxy(50,wall.y); std::cout &lt;&lt; \"|\"; wall.y++; } gotoxy(0, 30); while (wall.x &lt;= 50) { std::cout &lt;&lt; \"-\"; wall.x++; }} //蛇类 class Snake { private:sPoint&lt;double&gt; snakeHead;//蛇头的位置sPoint&lt;double&gt; snakeTail;//蛇尾的位置sPoint&lt;double&gt; snakeBody[n];//蛇身各点//int forwardTime;//前进的时间间隔Direction direction;char sym;int last; public:Snake() {};Snake(sPoint&lt;double&gt; head, sPoint&lt;double&gt; tail,int Last,sPoint&lt;double&gt; body[n]) { this-&gt;snakeHead = head; this-&gt;snakeTail = tail; this-&gt;last = Last; this-&gt;snakeBody[20] = body[20]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; snakeBody[0].x = 15; snakeBody[0].y = 15; snakeBody[1].x = 16; snakeBody[1].y = 15; snakeBody[2].x = 17; snakeBody[2].y = 15; snakeBody[3].x = 18; snakeBody[3].y = 15; last = 4;}//蛇向左转void setSnakeLeft(){ //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.x = snakeHead.x - 1; snakeHead.y = snakeHead.y; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y;}//蛇向右转void setSnakeRight(){ //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y; snakeHead.x = snakeHead.x+1; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y;}//蛇向上转void setSnakeUp(){ for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y - 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y;}//蛇向下转void setSnakeDown(){ for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y + 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y;}//蛇直走void setSnakeForward(){ if (snakeBody[0].y &lt; snakeBody[1].y) snakeHead.y = snakeHead.y - 1; if (snakeBody[0].y &gt; snakeBody[1].y) snakeHead.y = snakeHead.y + 1; if (snakeBody[0].x &lt; snakeBody[1].x) snakeHead.x = snakeHead.x - 1; if (snakeBody[0].x &gt; snakeBody[1].x) snakeHead.x = snakeHead.x + 1; for (int i = last; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y;}//蛇身加一点void addSnake(){ if (snakeBody[last - 1].y &lt; snakeBody[last - 2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y--; } if (snakeBody[last -1].y &gt; snakeBody[last -2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y++; } if (snakeBody[last -1].x &lt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x--; } if (snakeBody[last -1].x &gt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x++; } last++; snakeHead.x = snakeBody[0].x; snakeHead.y = snakeBody[0].y;} //判断蛇是否撞墙或撞自己int ifOut(){ //蛇是否到达边界 if (snakeBody[0].x == 50 || snakeBody[0].y == 30 || snakeBody[0].x == 0 || snakeBody[0].y == 0) return 0; //判断蛇是否撞到自己 for (int j = 1; j &lt;last; j++) { if ((snakeHead.x == snakeBody[j].x)&amp;&amp;(snakeHead.y == snakeBody[j].y)) return 0; } return 1;}//初步显示蛇的图案void snakeDisplay(){ gotoxy(snakeBody[0].x, snakeBody[0].y); std::cout &lt;&lt; \"*\";//显示蛇头 for (int a = 1; a &lt; last; a++) { //std::cout &lt;&lt; this-&gt;snakeBody[a].x &lt;&lt; this-&gt;snakeBody[a].y; gotoxy(snakeBody[a].x, snakeBody[a].y); std::cout &lt;&lt; \"#\"; }}//判断蛇是否吃到食物int ifEat(double x,double y){ if (this-&gt;snakeHead.x == x&amp;&amp;this-&gt;snakeHead.y == y) return true; else return false;} };int main() { double x, y, *a; sPoint&lt;double&gt; body[20];//用于存储身体各点坐标 system(\"cls\"); getWall(); Snake snake = Snake(sPoint&lt;double&gt;(15, 15), sPoint&lt;double&gt;(18, 15), 4, body);//初始化蛇 snake.snakeDisplay(); a=setFood(); x = a[0]; y = a[1]; char ch = '/0'; Sleep(5000); //当没有键按下，蛇往前走 while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(\"cls\"); getWall(); gotoxy(x,y); cout &lt;&lt; \"0\"; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(\"cls\"); getWall(); gotoxy(x, y); cout &lt;&lt; \"0\"; setFood(); snake.snakeDisplay(); } if (!snake.ifOut()) return 0; } while (1) { if (_kbhit()) { ch = _getche();//ch记录按下的键是什么 switch (ch) { case 'd': snake.setSnakeRight(); Sleep(200); system(\"cls\"); getWall(); gotoxy(x, y); cout &lt;&lt; \"0\"; snake.snakeDisplay(); break; case 'a': snake.setSnakeLeft(); Sleep(200); system(\"cls\"); getWall(); gotoxy(x, y); cout &lt;&lt; \"0\"; snake.snakeDisplay(); break; case 'w': snake.setSnakeUp(); Sleep(200); system(\"cls\"); getWall(); gotoxy(x, y); cout &lt;&lt; \"0\"; snake.snakeDisplay(); break; case 's': snake.setSnakeDown(); Sleep(200); system(\"cls\"); getWall(); gotoxy(x, y); cout &lt;&lt; \"0\"; snake.snakeDisplay(); break; case 'p': return 0; default: break; } } while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(\"cls\"); getWall(); gotoxy(x, y); cout &lt;&lt; \"0\"; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(\"cls\"); getWall(); gotoxy(x, y); cout &lt;&lt; \"0\"; setFood(); snake.snakeDisplay(); } } if (!snake.ifOut()) return 0; if (snake.ifEat(x,y)) { snake.addSnake(); system(\"cls\"); getWall(); a=setFood(); x = a[0]; y = a[1]; snake.snakeDisplay(); } } return 0; }","link":"/2019/09/03/控制台实现贪吃蛇/"},{"title":"OS-定时器制作(2)","text":"这次学习的仍然是定时器，以及提高性能。首先是测试性能，在判断中断的for循环里进行count++计数，当到了10秒之后就将count值显示出来，但在5秒处要归零（作者是在3秒处归零），这是因为电脑初始化所花费的时间有很大变化。然后通过优化FIFO缓冲区来进行性能提升。因为鼠标、键盘、各个定时器的中断，都使用了不同的缓冲区，这样在判断的时候就会很麻烦，所以采用同一个缓冲区，但往缓冲区送入的不同数字代表不同的中断。最后是加快定时器的中断处理，使用了线性链表和哨兵。我在这里总结一下定时器所采用的结构和方法（提升性能后有所变化）：定时器的结构体参数有：下一个超时的定时器、超时时间、使用标记、中断处理的缓冲区、该中断的数字号。定时器控制体的结构体参数有：计时器、下一个的超时时间、第一个定时器、存放500个定时器的数组。首先是初始化定时器：给每个定时器分配（就是存放500个定时器数组里的标志设为1），设置哨兵，往中断缓冲存入该定时器对应的数字号。若有中断到达则往缓冲区存入数字，并且将下一个会到达的超时定时器指定。由于定时器是线性链表结构排列，所以当有一个新的定时器加入时，要将新定时器插入链表，按照顺序排列。以下是成果图：","link":"/2019/12/21/自制简单操作系统（8）/"},{"title":"银行排队问题","text":"要解决的问题——银行一天之内的： 1.总客户数 2.客户总逗留时间 3.客户平均逗留时间 银行排队问题可具体化为一个银行、队伍、客户，将客户到达事件、客户离开事件等一系列事件作为事件链表，客户作为链表节点，银行作为一个类。 bank头文件： 1234567891011121314151617181920212223242526272829303132333435363738 #include &lt;queue&gt; #include &lt;list&gt; //事件链表 struct Event {int _occur_time;//事件发生时间int _type;//事件类型，0表示到达事件，1~4表示4个窗口离开事件 }; //银行链表的队伍结点 struct QueueNode {int _arrival_time;//客户到达时间int _duration_time;//客户在银行待的时间 }; //银行链表 class Bank { public://防止隐式转化explicit Bank(int window = 4, int close_time = 8 * 3600);~Bank();void Simulation(); private:int _queue_number; //队列个数int _close_time; //关门时间int _total_time;//所有客人待的总时间int _customer_number;//客户数目std::list&lt;Event&gt; _event_list;//事件链表std::queue&lt;QueueNode&gt; *_work_queue;//工作队伍队列void OpenForDay();void CustomerArrival(Event *event);//客户到达事件void CustomerDeparture(Event *event);//客户离开事件int FindShortestQueue();void SortEventList(); }; bank.cpp: #include \"pch.h\" #include &lt;iostream&gt; #include \"bank.h\" #include &lt;clocale&gt; #include &lt;chrono&gt; #include &lt;cstdlib&gt; Bank::Bank(int window, int close_time) :_queue_number(window), _close_time(close_time), _total_time(0), _customer_number(0) { _work_queue = new std::queue&lt;QueueNode&gt;[window];//产生一个新的工作队列 srand(std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()));//产生伪随机序列 } Bank::~Bank() { delete[] _work_queue; } void Bank::OpenForDay() { //第一个客户到达,将第一个客户到达事件压入栈 _event_list.push_back({ 0,0 }); } void Bank::CustomerArrival(Event *event) { ++_customer_number;//客户数加一 int duration_time, inter_time;//inter_time:下一个客户隔多长时间来 duration_time = rand() % 1800 + 1;//一个客户最多30分钟 inter_time = rand() % 600 + 1;//最多10分钟来一个客户 //下一个客户到达时间 int t = event-&gt;_occur_time + inter_time; //假设银行未关门 if (t &lt; _close_time) { _event_list.push_back({ t,0 });//将下一个客户到达事件压栈 SortEventList();//整理、排序事件 } int i; i = FindShortestQueue();//i为最短队列 //将新客户压入最短队列 _work_queue[i].push({ event-&gt;_occur_time,duration_time }); //生成i队列最后一个人的离开事件 if (_work_queue[i].size() == 1) { _event_list.push_back({ event-&gt;_occur_time + duration_time,i + 1 }); SortEventList(); } } void Bank::CustomerDeparture(Event *event) { int i = event-&gt;_type - 1;//i表示1~4哪个队伍离开 QueueNode customer; //客户离开，从队伍中弹出 customer = _work_queue[i].front(); _work_queue[i].pop(); //客户总耗时=之前的耗时+此刻的耗时 _total_time += event-&gt;_occur_time - customer._arrival_time; if (!_work_queue[i].empty()) { customer = _work_queue[i].front(); _event_list.push_back( { customer._duration_time + event-&gt;_occur_time, i + 1 }); SortEventList(); } } int Bank::FindShortestQueue() { int result = 0; for (int i = 0; i &lt; _queue_number; ++i) { if (_work_queue[result].size() &gt; _work_queue[i].size()) result = i; } return result; } void Bank::SortEventList() { // Lambda表达式 _event_list.sort([](const Event &amp;e1, const Event &amp;e2) -&gt; bool {return e1._occur_time &lt; e2._occur_time; }); } //模拟仿真排队 void Bank::Simulation() { OpenForDay(); Event event; while (!_event_list.empty()) { event = _event_list.front(); _event_list.pop_front(); if (event._type == 0) // 到达事件 CustomerArrival(&amp;event); else CustomerDeparture(&amp;event); } // 计算并输出平均逗留时间 std::wcout &lt;&lt; L\"客户数：\" &lt;&lt; _customer_number &lt;&lt; std::endl &lt;&lt; L\"总逗留时间（小时）：\" &lt;&lt; (double)_total_time / 3600.0 &lt;&lt; std::endl &lt;&lt; L\"平均逗留时间（分钟）：\" &lt;&lt; (double)_total_time / (double)(_customer_number * 60) &lt;&lt; std::endl; } int wmain(int argc, wchar_t *argv[], wchar_t *env[]) { _wsetlocale(LC_ALL, L\"\"); Bank bank; bank.Simulation(); return 0; }","link":"/2019/08/28/银行排队问题/"},{"title":"递归问题","text":"最近数据结构刚刚学了递归问题，感觉理解的不太到位，刚好leetcode刷题刷到了两个递归问题，对递归算是更进一步理解了吧。 leetcode—22.括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 当加入一个左括号时，剩余的可看作新的组合，但右括号的个数必须大于左括号的个数时，才表明可以加入右括号，C++代码如下： 1234567891011121314151617vector&lt;string&gt; res;void back(string s,int i,int j){ int n; if(i==0&amp;&amp;j==0) { res.push_back(s); return; } if(i&gt;0) back(s+'(',i-1,j); if(j&gt;i) back(s+')',i,j-1); }vector&lt;string&gt; generateParenthesis(int n) { back(\"\",n,n); return res;} leetcode—39.组合总数 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 利用递归求解，将数组中的第一个数提取出来，则可以看作是求candidates中所有可以使数字和为（target-第一个数字）的组合，以此类推，但必须注意不能有重复的组合，所以应该在后面的数被提取时，不能与前面的数相匹配。C++代码如下： 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; tmp;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { com(0,candidates,target); return res;}void com(int cur,vector&lt;int&gt;&amp; candidates,int target){ int t; t=target; for(int i=cur;i&lt;candidates.size();i++) { if(target==0) { res.push_back(tmp); return; } if(target&gt;0) { tmp.push_back(candidates[i]); com(i,candidates,target-candidates[i]); tmp.pop_back(); } else continue; target=t; }}","link":"/2019/06/02/递归问题/"},{"title":"飞机射击小游戏","text":"fsObject.h: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360 #pragma once #include &lt;iostream&gt; #include &lt;chrono&gt; #ifndef FSOBJECTS_H #define FSOBJECTS_H using namespace std; namespace flightShooting { #define FSOBJECTS_H #define FS_DEFAULT_FIRE_INTERVAL std::chrono::milliseconds(500) // 默认的开火间隔 #define FS_DEFAULT_FRAME_INTERVAL 10 // 默认的刷新频率，即每隔多少毫秒刷新一次 #define FS_DEFAULT_MOVE_STEP 0.01 // 在moveleft()方法和moveright()方法中默认的每次移动距离 #define FS_MOVE_LEFT_KEY 'a' // 控制玩家飞机向左移动一个单位所对应的按键 #define FS_MOVE_RIGHT_KEY 'd' // 控制玩家飞机向右移动一个单位所对应的按键 #define FS_ESCAPE_KEY ' ' // 退出游戏所使用的按键 #define FS_DEFAULT_BULLET_FLY_SPEED 3.0 // 默认子弹飞行速度，3代表每秒飞行三个屏幕 #define FS_DEFAULT_AIRCRAFT_FLY_SPEED 0.1 // 默认的飞机飞行速度 #define FS_DEFAULT_BULLET_COLOR fsColor(255,0,0,0) // 默认子弹颜色 #define FS_DEFAULT_BULLET_SIZE 0.1 //默认的子弹正方形边长 #define FS_DEFAULT_BULLET_SIZE_X 0.05 //默认的子弹长方形在x轴方向的长度 #define FS_DEFAULT_BULLET_SIZE_Y 0.1 //默认的子弹长方形在y轴方向的长度 #define FS_DEFAULT_PLAYER_SYMBOL '*' // 默认的玩家的飞机的符号 #define FS_DEFAULT_ENEMY_SYMBOL '+' // 默认的敌人的飞机的符号 #define FS_DEFAULT_BULLET_SYMBOL 'o' // 默认的子弹的符号 #define FS_DEFAULT_SCOREBOARD_COLOR fsColor(0,255,0,0) // 默认的计分版颜色// 默认的边界位置，这些位置主要在move*方法中限制物体不要超出屏幕边界 #define FS_DEFAULT_COORD_LOWER_LIMIT 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_X 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_X 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_Y 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_Y 0.95// 飞机子弹来源template&lt;typename T&gt;class fsPoint{public: T x, y; fsPoint() {}; fsPoint(T xval, T yval) :x(xval), y(yval) {}; fsPoint&lt;T&gt; &amp; operator = (const fsPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this; }};//飞机子弹的来源enum bulletSource{ player = 1, enemy = 2, playerFriend = 3//分别来自玩家、敌方、玩家朋友};//子弹射击方向enum direction{ up = 1, down = 2, right = 3, left = 4};/*enum symbol{ play = FS_DEFAULT_PLAYER_SYMBOL,en= FS_DEFAULT_ENEMY_SYMBOL,bullet=FS_DEFAULT_BULLET_SYMBOL};*/class fsInvalidInitializePointValException : public std::logic_error {public: fsInvalidInitializePointValException() :std::logic_error(\"Invalid initialze fsPoints!\") {};};class fsOutRangeMoveToPointException : public std::logic_error {public: fsOutRangeMoveToPointException() : std::logic_error(\"the move to point is out of the range of 0 to 1 for either x or y\") {};};class fsInvalidFireTimeException :public std::logic_error {public: fsInvalidFireTimeException() :std::logic_error(\"Not right time to fire!\") {};};class fsInvalidBulletSpeedInException : public std::logic_error {public: fsInvalidBulletSpeedInException() : std::logic_error(\"bullet speed in must be a positive number!\") {};};class fsColor {public: unsigned char r, g, b, a; //全部为0~255 0 表示完全不透明 fsColor() {}; fsColor(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) : r(red), g(green), b(blue), a(alpha) {};};//游戏中所用物体的基类class fsObject {private: fsPoint&lt;double&gt; upperLeftCorner; // the position fsPoint&lt;double&gt; lowerRightCorner; fsColor foregroundColor; char symbol; int visible; // 物体是否可见，如果为0则不可见public: fsObject() {}; //物体的位置、颜色、符号 fsObject(const fsPoint&lt;double&gt; &amp;upperleft, const fsPoint&lt;double&gt; &amp;lowerright, const fsColor &amp;fgc, char sym = 0) { if (upperleft.x &gt; lowerright.x || upperleft.y &gt; lowerright.y) throw fsInvalidInitializePointValException(); this-&gt;upperLeftCorner = upperleft; this-&gt;lowerRightCorner = lowerright; this-&gt;foregroundColor = fgc; this-&gt;symbol = sym; this-&gt;visible = 1; } //获得左上角位置 fsPoint&lt;double&gt; getUpperLeftCorner() const { return this-&gt;upperLeftCorner; } //获得右下角位置 fsPoint&lt;double&gt; getLowerRightCorner() const { return this-&gt;lowerRightCorner; } //获得符号 char getSymbol() const { return this-&gt;symbol; } //设置符号 void setSymbol(char c) { this-&gt;symbol = c; } //设置为可见 int getVisible() const { return this-&gt;visible; } //获得是否可见 void setVisible(int newVisible) { this-&gt;visible = newVisible; return; } // 移动位置，向左移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveleft() { if (this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP &lt; 0) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x - FS_DEFAULT_MOVE_STEP; return 1; } // 移动位置，向右移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveright() { if (this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP &gt; 1) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP; return 1; } //检测竖直方向上移位是否正确 int moveVertically(double delta) { if (this-&gt;upperLeftCorner.y + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_UPPER_LIMIT_Y; return 0; } if (this-&gt;upperLeftCorner.y + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_LOWER_LIMIT_Y; return 0; } this-&gt;upperLeftCorner.y = this-&gt;upperLeftCorner.y + delta; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.y + delta; return 1; } //在水平方向上移动位置，如果输入的delta导致物体的左上角超出屏幕，就将其置为最近的FS_DEFAULT_COORD_UPPER_LIMIT_X或FS_DEFAULT_COORD_UPPER_LIMIT_X int moveHorizontally(double delta) { if (this-&gt;upperLeftCorner.x + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_UPPER_LIMIT_X; return 0; } if (this-&gt;upperLeftCorner.x + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_LOWER_LIMIT_X; return 0; } this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + delta; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + delta; return 1; } //将物体的右下角移动到一点 int movePoint(const fsPoint&lt;double&gt; &amp;dest) { if (dest.x &gt; 1 || dest.x &lt; 0 || dest.y &gt;1 || dest.y &lt; 0) { throw fsOutRangeMoveToPointException(); } this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + dest.x - this-&gt;upperLeftCorner.x; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.x + dest.y - this-&gt;upperLeftCorner.y; this-&gt;upperLeftCorner = dest; } void printpos() const { cout &lt;&lt; \"ULC:\" &lt;&lt; (this-&gt;getLowerRightCorner()).x &lt;&lt; \" \" &lt;&lt; (this-&gt;getLowerRightCorner()).y &lt;&lt; endl; return; }};//子弹类class fsBullet :public fsObject {private: fsObject bullet; bulletSource source; direction bulletDirection; // 飞行方向 double vec; // 飞行速度，目前暂时不允许子弹斜着飞 并且不允许是负数 int bulletDamage; std::chrono::high_resolution_clock::time_point lastPositionUpdateTime;public: fsBullet() {}; fsBullet(bulletSource sourceOfBullet, direction directionOfBullet, int damageOfBullet, fsPoint&lt;double&gt; sourceulc, double bulletVec = FS_DEFAULT_BULLET_FLY_SPEED) : fsObject(sourceulc, fsPoint&lt;double&gt;(sourceulc.x + FS_DEFAULT_BULLET_SIZE_X, sourceulc.y + FS_DEFAULT_BULLET_SIZE_Y), FS_DEFAULT_BULLET_COLOR), source(sourceOfBullet), bulletDirection(directionOfBullet), bulletDamage(damageOfBullet), lastPositionUpdateTime(std::chrono::high_resolution_clock::now()) { if (bulletVec &lt; 0) throw fsInvalidBulletSpeedInException(); this-&gt;vec = bulletVec; if (this-&gt;bulletDirection == up) vec = vec * -1; bullet.setSymbol(FS_DEFAULT_BULLET_SYMBOL); } //更新子弹位置 int updataPosition() { std::chrono::microseconds timeelapsed = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::high_resolution_clock::now() - this-&gt;lastPositionUpdateTime); double delta = 1.0 * timeelapsed.count() / 1000000 * vec; //cout &lt;&lt; \"delta\" &lt;&lt; delta &lt;&lt; endl; this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); if (bullet.moveVertically(delta) == 0) return 0; return 1; }};//所有飞机的基类class fsAircraft :public fsObject {private: chrono::milliseconds fireInterval; // 两发炮弹之间的间隔，单位为ms chrono::steady_clock::time_point lastFireTime; int lifeLeft = 1; // 剩余的生命值 int bulletDamage = 1; // 默认的机体伤害值 bulletSource source; direction bullteDirection;public: fsAircraft() {}; fsAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsObject(upperleft, lowerright, fgc), fireInterval(fireinterval) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); }; inline int fireReady() { if (chrono::high_resolution_clock::now() - this-&gt;lastFireTime &gt; fireInterval) { return 1; } return 0; } // 强制发射子弹，返回fsBullet的对象，即该飞机所发射的子弹 fsBullet fire() { //if (fireReady()) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); return fsBullet(this-&gt;source, this-&gt;bullteDirection, this-&gt;bulletDamage, this-&gt;getUpperLeftCorner()); //} //throw fsInvalidFireTimeException(); } int setBullteDamage(int newBulletDamage) { this-&gt;bulletDamage = newBulletDamage; return 0; } // 设置飞机是玩家的飞机还是敌人的飞机 void setSource(bulletSource newSource) { this-&gt;source = newSource; } // 设置新的子弹飞行方向 void setFireDirection(direction newDirection) { this-&gt;bullteDirection = newDirection; } //返回剩余生命值，当返回0或者负数时说明死亡（本程序中没有使用） int getLifeLeft() const { return this-&gt;lifeLeft; } int gotHit(int bulletDamage = 1) { if (this-&gt;lifeLeft - bulletDamage &lt;= 0) { this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; return 0; } this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; }};//玩家的飞机class fsMyAircraft :public fsAircraft {public: fsMyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，发射子弹后，再经过此段时间后才能再次发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(player); this-&gt;setFireDirection(up); this-&gt;setSymbol(FS_DEFAULT_PLAYER_SYMBOL); };};//敌方的飞机class fsEnemyAircraft : public fsAircraft {private: std::chrono::high_resolution_clock::time_point lastPositionUpdateTime; // 最后一次更新物体位置的时间 std::chrono::high_resolution_clock::time_point lastDirectionUpdateTime; // 最后一次更新运动方向的时间 double vec; // 飞行速度，指在水平方向上的飞行速度 std::chrono::milliseconds directionUpdateInterval; // 两次速度方向更新之间的时间间隔，最好能用随机数产生public: fsEnemyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(enemy); this-&gt;setFireDirection(down); this-&gt;setSymbol(FS_DEFAULT_ENEMY_SYMBOL); this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;directionUpdateInterval = std::chrono::milliseconds(1000); this-&gt;vec = FS_DEFAULT_AIRCRAFT_FLY_SPEED; } // 更新敌机的位置，敌机随机移动，每隔一段时间更换一个方向，移动会在一个矩形框中进行 int updatePosition() { // 是否要更换方向 if (std::chrono::high_resolution_clock::now() - lastDirectionUpdateTime &gt; directionUpdateInterval) { //产生一个新的方向 lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;vec = this-&gt;vec * (-1); srand((unsigned)time(NULL)); directionUpdateInterval = std::chrono::milliseconds(rand() / 5 + 1000); // 随机数的范围在1s到7s之间 } std::chrono::milliseconds elapsedtime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - lastPositionUpdateTime); lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;moveHorizontally(1.0 * elapsedtime.count() / 1000 * vec); return 0; }};// 计分版 用于记录玩家的分数class fsScoreBoard : public fsObject {private: int score = 0; // 每次击中算一分public: fsScoreBoard() {}; fsScoreBoard(const fsPoint&lt;double&gt; &amp; upperleft, // 计分版左上角的位置 推荐将左上角的横坐标设置为大于1的数，避免分数的显示与游戏画面重叠 const fsPoint&lt;double&gt; &amp; lowerright, // 计分版右下角的位置 const fsColor &amp; fgc = FS_DEFAULT_SCOREBOARD_COLOR // 计分版颜色，在控制台情况下无效 ) :fsObject(upperleft, lowerright, fgc) { ; } // 获取计分版分数 int getCurScore() const { return this-&gt;score; } // 增加得分 void addScore(int delta = 1) { this-&gt;score = this-&gt;score + 1; }};// 判断两个物体是否重叠 如果重叠将返回1 否则返回0，主要用来判定子弹是否击中了飞机int fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) ;// 判断一个点是否在一个矩形中，包括在矩形边上的情况template &lt;typename T&gt;bool fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight);int fsInitialize();//int fsGameLoop(); } #endif fsDraw.h： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223 #pragma once #include \"fsObject.h\" #include &lt;Windows.h&gt; #include &lt;conio.h&gt; #ifndef FSDRAW_H #define FSDRAW_H using namespace flightShooting; using namespace std; namespace flightShooting { #define FS_DEFAULT_CONSOLE_BUFFER_SCALE 50 //光标位置 void gotoxy(int x, int y) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(consoleBuf, pos); } //设置颜色 void setcolor(WORD color) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color); } void setcolor(WORD color, HANDLE consoleBuf) { SetConsoleTextAttribute(consoleBuf, color); } //画出对象 int fsDraw(const fsObject &amp; fso) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED); cout &lt;&lt; fso.getSymbol(); return 0; } int fsDraw(const fsObject &amp; fso, HANDLE consoleBuf) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED, consoleBuf); cout &lt;&lt; fso.getSymbol(); return 0; } //画出计分板 int fsDrawScoreBoard(const fsScoreBoard &amp;fsb) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_GREEN); cout &lt;&lt; \"SCORE: \" &lt;&lt; fsb.getCurScore(); return 0; } int fsDrawScoreBoard(const fsScoreBoard &amp; fsb, HANDLE consoleBuf) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_GREEN, consoleBuf); cout &lt;&lt; \"SCORE: \" &lt;&lt; fsb.getCurScore(); return 0; } // 用空格填充控制台的缓存 int fsFillWithBlank() { gotoxy(0, 0); for (int i = 0; i &lt; 1000 * 1000; ++i) { cout &lt;&lt; \" \"; } return 0; } } #endif``` test.h:```cpp int gameTestOneBuf() { // 初始化玩家飞机 fsMyAircraft playerAircraft = fsMyAircraft(fsPoint&lt;double&gt;(0.5, 0.99), fsPoint&lt;double&gt;(0.51, 1.00), fsColor(255, 255, 255, 0)); // 初始化敌方飞机 fsEnemyAircraft enemy1 = fsEnemyAircraft(fsPoint&lt;double&gt;(0.5, 0.10), fsPoint&lt;double&gt;(0.51, 0.11), fsColor(255, 0, 0, 0)); // 初始化计分板 fsScoreBoard scoreBoard = fsScoreBoard(fsPoint&lt;double&gt;(1.1, 0.3), fsPoint&lt;double&gt;(1.11, 0.31)); // 等待1s以便能够通过fire函数成功初始化子弹 Sleep(1000); fsBullet mybullet; if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } fsBullet enemybullet; if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } // 初始化键盘按键存储变量 char ch = '/0'; // 游戏循环 while (1) { // 获取按键 if (_kbhit()) { ch =_getche(); } // 依据不同的按键做出对应的反应 switch (ch) { case FS_MOVE_LEFT_KEY: playerAircraft.moveleft(); break; case FS_MOVE_RIGHT_KEY: playerAircraft.moveright(); break; case FS_ESCAPE_KEY: cout &lt;&lt; \"You ended this game!\"; return 0; default: break; } ch = 0; // 更新各对象的状态 if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } mybullet.updataPosition(); enemybullet.updataPosition(); enemy1.updatePosition(); // 呈现图像 system(\"cls\"); fsDraw(playerAircraft); fsDraw(mybullet); fsDraw(enemy1); fsDraw(enemybullet); fsDrawScoreBoard(scoreBoard); // 子弹击中的判定，如果子弹击中，则将原来的子弹设为不可见 if (fsOverlap(mybullet, enemy1)) { scoreBoard.addScore(); mybullet.setVisible(0); } if (fsOverlap(enemybullet, playerAircraft)) { cout &lt;&lt; \"you are hit!\"; enemybullet.setVisible(0); Sleep(500); } Sleep(FS_DEFAULT_FRAME_INTERVAL); } return 0; }``` fsObject.cpp:```cpp #include \"pch.h\" #include &lt;iostream&gt; #include &lt;iostream&gt; #include &lt;Windows.h&gt; #include &lt;chrono&gt; #include &lt;vector&gt; #include &lt;conio.h&gt; #include \"fsObject.h\" using namespace std; using namespace flightShooting; int flightShooting::fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) { if (obj1.getVisible() == 0 || obj2.getVisible() == 0) return 0; // 重叠判定要稍微费点脑筋 // 判断矩形是否重叠，只需要对每个矩形，分别判断其四个顶点是否在另外一个矩形内 const fsPoint&lt;double&gt; obj1ulc = obj1.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj1lrc = obj1.getLowerRightCorner(); const fsPoint&lt;double&gt; obj1urc = fsPoint&lt;double&gt;(obj1lrc.x, obj1ulc.y); const fsPoint&lt;double&gt; obj1llc = fsPoint&lt;double&gt;(obj1ulc.x, obj1lrc.y); const fsPoint&lt;double&gt; obj2ulc = obj2.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj2lrc = obj2.getLowerRightCorner(); const fsPoint&lt;double&gt; obj2urc = fsPoint&lt;double&gt;(obj2lrc.x, obj2ulc.y); const fsPoint&lt;double&gt; obj2llc = fsPoint&lt;double&gt;(obj2ulc.x, obj2lrc.y); // bool test = fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj1InObj2 = fsPointInRect(obj1ulc, obj2ulc, obj2lrc) || fsPointInRect(obj1urc, obj2ulc, obj2lrc) || fsPointInRect(obj1llc, obj2ulc, obj2lrc) || fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj2InObj1 = fsPointInRect(obj2ulc, obj1ulc, obj1lrc) || fsPointInRect(obj2urc, obj1ulc, obj1lrc) || fsPointInRect(obj2llc, obj1ulc, obj1lrc) || fsPointInRect(obj2lrc, obj1ulc, obj1lrc); return obj1InObj2 || obj2InObj1; } template&lt;typename T&gt; bool flightShooting::fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight) { return (point.x &gt;= RectUpperLeft.x &amp;&amp; point.x &lt;= RectLowerRight.x) &amp;&amp; (point.y &gt;= RectUpperLeft.y &amp;&amp; point.y &lt;= RectLowerRight.y); }``` fsTest.cpp:```cpp #include &lt;iostream&gt; #include \"pch.h\" #include \"fsObject.h\" #include \"fsTest.h\" using namespace std; using namespace flightShooting; int main() { gameTestOneBuf(); return 0;}","link":"/2019/08/31/飞机射击小游戏-1/"},{"title":"OS-定时器制作(1)","text":"这次学习了定时器的设置和加快中断处理。与鼠标键盘一样，定时器是通过中断处理实现的。有一个类似于8253的计数器，不停的向cpu发送脉冲，每接受一次脉冲就产生一次中断。定时器也是用结构体实现。每个定时器设有一个超时变量，当初始化计数器后就开始计数，如果数目达到了某个定时器的超时变量，就代表该定时器已经到达设定的时间，就可以往定时器设定的缓冲区发送字节（与键盘鼠标类似）。一旦发现该缓冲区有字节后就开始执行特定的命令。这就是定时器的基本工作原理。加快中断处理是针对定时器的中断。主要是将每个定时器按照超时的大小进行排序存储（与图层设定类似），这样每次判断该定时器是否工作或到达设定时间时，就可以少执行几次for循环。以下是这次实验的成果图：","link":"/2019/12/18/自制简单操作系统（7）/"},{"title":"回溯法","text":"三个例题来说明回溯法，分别是皇后问题、素数环、困难的串。首先是这种类型的题的思路：一般回溯法的问题可以看成有条件限制的全排列或者子集生成。例如皇后问题，里面的限制条件就是行、列、对角线不能有皇后同时存在，如果存在，就返回上一行，重新定义上一行的皇后所在的列。它的解答树：每一个回溯问题都可以画出解答树，然后再加上限定条件，进行递归。 皇后问题： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;//c[x]表示第x行的皇后的列的编号int c[4];void pailie(int l, int r,int c[4]) { if (l == r) { for (int i = 0; i &lt; r; i++) { cout &lt;&lt; c[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } else { for (int i = 0; i &lt; r; i++) { int ok = 1; c[l] = i; for (int j = 0; j &lt; l; j++) { if (c[l] == c[j] || l - c[l] == j - c[j] || l + c[l] == j + c[j]) {//列相等和对角线相等 ok = 0; break; } } if (ok) { pailie(l + 1, r, c); } } }}int main() { pailie(0, 4, c); return 0;} 素数环（Prime Ring Problem, UVa 524）输入正整数n，把整数1, 2, 3,…, n组成一个环，使得相邻两个整数之和均为素数。输出 时从整数1开始逆时针排列。同一个环应恰好输出一次。n≤16。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int a[6];bool isprem(int n) { int i; for (i = 2; i &lt;= n / 2; i++) { int x = 9; if (n % i == 0) return false; } return true;}void pailie(int l, int r, int a[6]) { if ((l == r)&amp;&amp;isprem(a[0]+a[5])) { for (int i = 0; i &lt; r; i++) { cout &lt;&lt; a[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } else { for (int i = 1; i &lt;= r; i++) { int ok = 1; for (int j = 0; j &lt; l; j++) { if (a[j] == i) ok = 0; } if(ok&amp;&amp;isprem(a[l-1]+i)){ a[l] = i; pailie(l + 1, r, a); } } }}int main() { pailie(0, 6, a); return 0;} 困难的串（Krypton Factor, UVa 129）如果一个字符串包含两个相邻的重复子串，则称它是“容易的串”，其他串称为“困难的 串”。例如，BB、ABCDACABCAB、ABCDABCD都是容易的串，而D、DC、ABDAB、 CBABCBA都是困难的串。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;char A[3] = { 'A','B','C' };void paixu(int l, char a[10], int n) { for (int i = 0; i &lt; l; i++) cout &lt;&lt; a[i]; cout &lt;&lt; endl; for (int i = 0; i &lt; n; i++) { int ok = 1; a[l] = A[i]; if (a[l] == a[l - 1]) ok = 0; for (int j = 1; j * 2 &lt;= l + 1; j++) { int equal = 1; for (int k = 0; k &lt; j; k++) { if (a[l - k] != a[l - k - j]) { equal = 0; break; } } if (equal) { ok = 0; break; } } if (ok) { paixu(l + 1, a, n); } }}int main() { int n, l; n = 7; l = 3; char a[10]; paixu(0, a, l); return 0;}","link":"/2020/01/16/回溯法/"},{"title":"子集生成","text":"子集生成算法：给定一个集合，枚举所有可 能的子集（无重复元素）子集生成有三种算法：增量构造法、位向量法、二进制法增量构造法: 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int p[4] = { 1,2,3,4 };int a[4];void ziji(int l,int r,int a[4]) { int i; for (i = 0; i &lt; l; i++) { //直接输出 cout &lt;&lt; a[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; int s; if (l == 0) s = 0; else //如果l不为0，a的第一个数应该从l开始 s = a[l-1]+1; for (i = s; i &lt; r; i++) { //l为0的情形： //假设i=0，然后a的第一个数为0，接着构造123的子集 //假设i=1，然后a的第一个数为1，接着构造23的子集...... //l为1的情形： //i=1、2、3，a的第二、三、四个数分别为1、2、3 //然后l继续增加，直到a有4个数 //l增加一个，就输出一组 //l增加完后，开始新的一轮，a的第一个数为1...... a[l] = i; ziji(l + 1, r, a); }}int main() { ziji(0, 4, a); return 0;} 位向量法： 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int b[4];void wei(int l,int r,int b[4]) { if (l == r) { for (int i = 0; i &lt; r; i++) { if (b[i]) cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl; return; } b[l] = 1;//该元素在枚举的集合中 wei(l + 1, r, b);//枚举剩下的 b[l] = 0;//该元素不在枚举的集合中 wei(l + 1, r, b);//枚举剩下的}int main() { wei(0, 4, b); return 0;} 二进制法 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;void two(int n,int s) { for (int i = 0; i &lt; n; i++) { //输出子集 if (s &amp; (1 &lt;&lt; i)) cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main() { int n; while(cin&gt;&gt;n){ for (int i = 0; i &lt; (1 &lt;&lt; n); i++) //假如输入的n是3，此时将0，1，2的子集全部列举出来 two(n, i); } return 0;}","link":"/2020/01/16/子集生成/"}],"tags":[{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"}],"categories":[{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"c++","slug":"c","link":"/categories/c/"}]}