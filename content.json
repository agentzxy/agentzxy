{"pages":[],"posts":[{"title":"scrapy框架爬取豆瓣电影top250","text":"在items里主要有五个item：序号、电影名字、电影标签、评分、图片url 由于只爬取了电影，所以movie.py里只有电影这一个spider。里面的parse函数利用xpath将搜索出来的数据导入items里的各个item的列表中，具体代码如下： def parse(self, response): html=response.text html=etree.HTML(html) order=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div/em&apos;)#序号 title=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;pic&quot;]/a/img/@alt&apos;) inq=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;info&quot;]/div[@class=&quot;bd&quot;]/p[@class=&quot;quote&quot;]/span&apos;) rating_num=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;info&quot;]/div[@class=&quot;bd&quot;]/div/span[@class=&quot;rating_num&quot;]&apos;) image_url=html.xpath(&apos;//ol[@class=&quot;grid_view&quot;]/li/div/div[@class=&quot;pic&quot;]/a/img/@src&apos;) item=movieItem() item[&apos;nums&apos;]=order item[&apos;names&apos;]=title item[&apos;tags&apos;]=inq item[&apos;scores&apos;]=rating_num item[&apos;images&apos;]=image_url yield item 注意一定要yield item，不然无法对items里面的进行数据处理 然后就是利用pipeline对数据处理，分为三个，分别是原始的、传入mysql的、将剧照保存的。 传入mysql： def process_item(self,item,spider): for i in range(24): sql=&quot;INSERT INTO top250(NUM,NAME,TAG,SCORE) VALUES(%s,%s,%s,%s)&quot; num=item[&apos;nums&apos;][i].text name=item[&apos;names&apos;][i] tag=item[&apos;tags&apos;][i].text score=item[&apos;scores&apos;][i].text s=(num,name,tag,score) self.cursor.execute(sql,s) self.db.commit() return item 保存图片的： def process_item(self,item,spider): for i in range(24): splitPath=item[&apos;images&apos;][i].split(&apos;.&apos;) fTail=splitPath.pop() fileName=item[&apos;names&apos;][i]+&quot;.&quot;+fTail filepath=&quot;D:/ddddd/&quot;+fileName request.urlretrieve(item[&apos;images&apos;][i],filepath) 最后就是在settings里面设置一些参数，具体代码参见github","link":"/2019/11/14/crapy框架爬取豆瓣电影top250/"},{"title":"控制台实现贪吃蛇","text":"1.首先要有定义坐标的类，坐标类里参数包括(x,y)。 2.其次定义snake类。用蛇身各点坐标描述蛇的位置，可将蛇的位置分为蛇头和蛇身来描述，蛇头为一个坐标点，使用#表示，蛇身为一个数组，数组各值表示蛇身各点位置。再定义几个成员函数，包括蛇的上下左右移动、蛇吃到食物后变长、蛇直径前行、判断蛇是否出边界或撞向自己、蛇是否吃到食物、显示蛇的图案。 3.然后定义一些函数。有界面上围墙的形成、光标的移动、食物的随机产生。 4.最后通过主函数的调用实现。 cpp： #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &lt;Windows.h&gt; #define n 20 #include &lt;conio.h&gt; #include&lt;time.h&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include &quot;stdlib.h&quot; using namespace std; //控制光标 void gotoxy(int x, int y) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(consoleBuf, pos); } //坐标类 template&lt;typename T&gt; class sPoint { public: T x, y; sPoint() {}; sPoint(T xval, T yval) :x(xval), y(yval) {}; sPoint&lt;T&gt; &amp; operator = (const sPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this; } }; //方向 enum Direction { left=&apos;a&apos;,right=&apos;d&apos; }; //随机产生一个食物 double * setFood() { double *a=new double[2]; int x, y; srand(time(0));//随机种子 do { x = rand() % 50 + 1; y = rand() % 30 + 1; break; } while (1); gotoxy(x, y); a[0] = x; a[1] = y;//将生成的食物坐标存储起来 std::cout &lt;&lt; &apos;0&apos; ; return a; } //生成围墙 void getWall() { sPoint&lt;double&gt; wall; wall.x = 0; wall.y =0; while (wall.y &lt;= 30) { gotoxy(50,wall.y); std::cout &lt;&lt; &quot;|&quot;; wall.y++; } gotoxy(0, 30); while (wall.x &lt;= 50) { std::cout &lt;&lt; &quot;-&quot;; wall.x++; } } //蛇类 class Snake { private: sPoint&lt;double&gt; snakeHead;//蛇头的位置 sPoint&lt;double&gt; snakeTail;//蛇尾的位置 sPoint&lt;double&gt; snakeBody[n];//蛇身各点 //int forwardTime;//前进的时间间隔 Direction direction; char sym; int last; public: Snake() {}; Snake(sPoint&lt;double&gt; head, sPoint&lt;double&gt; tail,int Last,sPoint&lt;double&gt; body[n]) { this-&gt;snakeHead = head; this-&gt;snakeTail = tail; this-&gt;last = Last; this-&gt;snakeBody[20] = body[20]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; snakeBody[0].x = 15; snakeBody[0].y = 15; snakeBody[1].x = 16; snakeBody[1].y = 15; snakeBody[2].x = 17; snakeBody[2].y = 15; snakeBody[3].x = 18; snakeBody[3].y = 15; last = 4; } //蛇向左转 void setSnakeLeft() { //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.x = snakeHead.x - 1; snakeHead.y = snakeHead.y; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向右转 void setSnakeRight() { //蛇的后一点往前一点移动 for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y; snakeHead.x = snakeHead.x+1; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向上转 void setSnakeUp() { for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y - 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇向下转 void setSnakeDown() { for (int i = last-1; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeHead.y = snakeHead.y + 1; snakeHead.x = snakeHead.x; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇直走 void setSnakeForward() { if (snakeBody[0].y &lt; snakeBody[1].y) snakeHead.y = snakeHead.y - 1; if (snakeBody[0].y &gt; snakeBody[1].y) snakeHead.y = snakeHead.y + 1; if (snakeBody[0].x &lt; snakeBody[1].x) snakeHead.x = snakeHead.x - 1; if (snakeBody[0].x &gt; snakeBody[1].x) snakeHead.x = snakeHead.x + 1; for (int i = last; i &gt;= 1; i--) snakeBody[i] = snakeBody[i - 1]; snakeBody[0].x = snakeHead.x; snakeBody[0].y = snakeHead.y; } //蛇身加一点 void addSnake() { if (snakeBody[last - 1].y &lt; snakeBody[last - 2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y--; } if (snakeBody[last -1].y &gt; snakeBody[last -2].y) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].y++; } if (snakeBody[last -1].x &lt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x--; } if (snakeBody[last -1].x &gt; snakeBody[last -2].x) { snakeBody[last] = snakeBody[last - 1]; snakeBody[last].x++; } last++; snakeHead.x = snakeBody[0].x; snakeHead.y = snakeBody[0].y; } //判断蛇是否撞墙或撞自己 int ifOut() { //蛇是否到达边界 if (snakeBody[0].x == 50 || snakeBody[0].y == 30 || snakeBody[0].x == 0 || snakeBody[0].y == 0) return 0; //判断蛇是否撞到自己 for (int j = 1; j &lt;last; j++) { if ((snakeHead.x == snakeBody[j].x)&amp;&amp;(snakeHead.y == snakeBody[j].y)) return 0; } return 1; } //初步显示蛇的图案 void snakeDisplay() { gotoxy(snakeBody[0].x, snakeBody[0].y); std::cout &lt;&lt; &quot;*&quot;;//显示蛇头 for (int a = 1; a &lt; last; a++) { //std::cout &lt;&lt; this-&gt;snakeBody[a].x &lt;&lt; this-&gt;snakeBody[a].y; gotoxy(snakeBody[a].x, snakeBody[a].y); std::cout &lt;&lt; &quot;#&quot;; } } //判断蛇是否吃到食物 int ifEat(double x,double y) { if (this-&gt;snakeHead.x == x&amp;&amp;this-&gt;snakeHead.y == y) return true; else return false; } }; int main() { double x, y, *a; sPoint&lt;double&gt; body[20];//用于存储身体各点坐标 system(&quot;cls&quot;); getWall(); Snake snake = Snake(sPoint&lt;double&gt;(15, 15), sPoint&lt;double&gt;(18, 15), 4, body);//初始化蛇 snake.snakeDisplay(); a=setFood(); x = a[0]; y = a[1]; char ch = &apos;/0&apos;; Sleep(5000); //当没有键按下，蛇往前走 while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(&quot;cls&quot;); getWall(); gotoxy(x,y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; setFood(); snake.snakeDisplay(); } if (!snake.ifOut()) return 0; } while (1) { if (_kbhit()) { ch = _getche();//ch记录按下的键是什么 switch (ch) { case &apos;d&apos;: snake.setSnakeRight(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;a&apos;: snake.setSnakeLeft(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;w&apos;: snake.setSnakeUp(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;s&apos;: snake.setSnakeDown(); Sleep(200); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); break; case &apos;p&apos;: return 0; default: break; } } while (!_kbhit()) { snake.setSnakeForward(); Sleep(300); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; snake.snakeDisplay(); if (snake.ifEat(x, y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); gotoxy(x, y); cout &lt;&lt; &quot;0&quot;; setFood(); snake.snakeDisplay(); } } if (!snake.ifOut()) return 0; if (snake.ifEat(x,y)) { snake.addSnake(); system(&quot;cls&quot;); getWall(); a=setFood(); x = a[0]; y = a[1]; snake.snakeDisplay(); } } return 0; }","link":"/2019/09/03/控制台实现贪吃蛇/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/02/hello-world/"},{"title":"递归问题","text":"最近数据结构刚刚学了递归问题，感觉理解的不太到位，刚好leetcode刷题刷到了两个递归问题，对递归算是更进一步理解了吧。 leetcode—22.括号生成 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 当加入一个左括号时，剩余的可看作新的组合，但右括号的个数必须大于左括号的个数时，才表明可以加入右括号，C++代码如下： vector&lt;string&gt; res; void back(string s,int i,int j){ int n; if(i==0&amp;&amp;j==0) { res.push_back(s); return; } if(i&gt;0) back(s+&apos;(&apos;,i-1,j); if(j&gt;i) back(s+&apos;)&apos;,i,j-1); } vector&lt;string&gt; generateParenthesis(int n) { back(&quot;&quot;,n,n); return res; }leetcode—39.组合总数 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 利用递归求解，将数组中的第一个数提取出来，则可以看作是求candidates中所有可以使数字和为（target-第一个数字）的组合，以此类推，但必须注意不能有重复的组合，所以应该在后面的数被提取时，不能与前面的数相匹配。C++代码如下： vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { com(0,candidates,target); return res; } void com(int cur,vector&lt;int&gt;&amp; candidates,int target) { int t; t=target; for(int i=cur;i&lt;candidates.size();i++) { if(target==0) { res.push_back(tmp); return; } if(target&gt;0) { tmp.push_back(candidates[i]); com(i,candidates,target-candidates[i]); tmp.pop_back(); } else continue; target=t; } }","link":"/2019/06/02/递归问题/"},{"title":"利用Flask框架写一个简单的预约系统","text":"主要功能就是用户登录、管理员登录、利用邮箱注册、增加或取消个人或团体预约记录。系统不难做，但有时候有些点会卡着你一个多小时。 登录是通过查询数据库的结果为1来验证。注册邮箱时碰到一个问题卡了我很久，因为我发送验证码和注册两个都是提交到同一个页面，当注册submit时，由于前面发送验证码已经submit，所以此时填写的email等信息会为空，所以我利用了session机制，如果页面接收到的email等信息不为空，则将其加入session，等到为空时，直接利用session的值来提交到数据库。 同样的用户登录后，回退页面也要用session机制，将用户名和密码存储在其中，过期时间为10分钟。 在注册时发送的验证码应存储在redis数据库中，设置一个过期时间为60s，此时不建议用mysql之类的关系数据库，没必要。 这个预约系统是在档案馆值班的时间做的，挺有收获的，做完了回头看确实很简单，算是对web开发有了初步接触了。 具体代码见https://github.com/agentzxy/reservation-system.git","link":"/2019/12/05/用Flask框架写一个简单的预约系统/"},{"title":"银行排队问题","text":"要解决的问题——银行一天之内的： 1.总客户数 2.客户总逗留时间 3.客户平均逗留时间 银行排队问题可具体化为一个银行、队伍、客户，将客户到达事件、客户离开事件等一系列事件作为事件链表，客户作为链表节点，银行作为一个类。 bank头文件： #include &lt;queue&gt; #include &lt;list&gt; //事件链表 struct Event { int _occur_time;//事件发生时间 int _type;//事件类型，0表示到达事件，1~4表示4个窗口离开事件 }; //银行链表的队伍结点 struct QueueNode { int _arrival_time;//客户到达时间 int _duration_time;//客户在银行待的时间 }; //银行链表 class Bank { public: //防止隐式转化 explicit Bank(int window = 4, int close_time = 8 * 3600); ~Bank(); void Simulation(); private: int _queue_number; //队列个数 int _close_time; //关门时间 int _total_time;//所有客人待的总时间 int _customer_number;//客户数目 std::list&lt;Event&gt; _event_list;//事件链表 std::queue&lt;QueueNode&gt; *_work_queue;//工作队伍队列 void OpenForDay(); void CustomerArrival(Event *event);//客户到达事件 void CustomerDeparture(Event *event);//客户离开事件 int FindShortestQueue(); void SortEventList(); }; bank.cpp: #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &quot;bank.h&quot; #include &lt;clocale&gt; #include &lt;chrono&gt; #include &lt;cstdlib&gt; Bank::Bank(int window, int close_time) :_queue_number(window), _close_time(close_time), _total_time(0), _customer_number(0) { _work_queue = new std::queue&lt;QueueNode&gt;[window];//产生一个新的工作队列 srand(std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()));//产生伪随机序列 } Bank::~Bank() { delete[] _work_queue; } void Bank::OpenForDay() { //第一个客户到达,将第一个客户到达事件压入栈 _event_list.push_back({ 0,0 }); } void Bank::CustomerArrival(Event *event) { ++_customer_number;//客户数加一 int duration_time, inter_time;//inter_time:下一个客户隔多长时间来 duration_time = rand() % 1800 + 1;//一个客户最多30分钟 inter_time = rand() % 600 + 1;//最多10分钟来一个客户 //下一个客户到达时间 int t = event-&gt;_occur_time + inter_time; //假设银行未关门 if (t &lt; _close_time) { _event_list.push_back({ t,0 });//将下一个客户到达事件压栈 SortEventList();//整理、排序事件 } int i; i = FindShortestQueue();//i为最短队列 //将新客户压入最短队列 _work_queue[i].push({ event-&gt;_occur_time,duration_time }); //生成i队列最后一个人的离开事件 if (_work_queue[i].size() == 1) { _event_list.push_back({ event-&gt;_occur_time + duration_time,i + 1 }); SortEventList(); } } void Bank::CustomerDeparture(Event *event) { int i = event-&gt;_type - 1;//i表示1~4哪个队伍离开 QueueNode customer; //客户离开，从队伍中弹出 customer = _work_queue[i].front(); _work_queue[i].pop(); //客户总耗时=之前的耗时+此刻的耗时 _total_time += event-&gt;_occur_time - customer._arrival_time; if (!_work_queue[i].empty()) { customer = _work_queue[i].front(); _event_list.push_back( { customer._duration_time + event-&gt;_occur_time, i + 1 }); SortEventList(); } } int Bank::FindShortestQueue() { int result = 0; for (int i = 0; i &lt; _queue_number; ++i) { if (_work_queue[result].size() &gt; _work_queue[i].size()) result = i; } return result; } void Bank::SortEventList() { // Lambda表达式 _event_list.sort([](const Event &amp;e1, const Event &amp;e2) -&gt; bool {return e1._occur_time &lt; e2._occur_time; }); } //模拟仿真排队 void Bank::Simulation() { OpenForDay(); Event event; while (!_event_list.empty()) { event = _event_list.front(); _event_list.pop_front(); if (event._type == 0) // 到达事件 CustomerArrival(&amp;event); else CustomerDeparture(&amp;event); } // 计算并输出平均逗留时间 std::wcout &lt;&lt; L&quot;客户数：&quot; &lt;&lt; _customer_number &lt;&lt; std::endl &lt;&lt; L&quot;总逗留时间（小时）：&quot; &lt;&lt; (double)_total_time / 3600.0 &lt;&lt; std::endl &lt;&lt; L&quot;平均逗留时间（分钟）：&quot; &lt;&lt; (double)_total_time / (double)(_customer_number * 60) &lt;&lt; std::endl; } int wmain(int argc, wchar_t *argv[], wchar_t *env[]) { _wsetlocale(LC_ALL, L&quot;&quot;); Bank bank; bank.Simulation(); return 0; }","link":"/2019/08/28/银行排队问题/"},{"title":"飞机射击小游戏","text":"fsObject.h: #pragma once #include &lt;iostream&gt; #include &lt;chrono&gt; #ifndef FSOBJECTS_H #define FSOBJECTS_H using namespace std; namespace flightShooting { #define FSOBJECTS_H #define FS_DEFAULT_FIRE_INTERVAL std::chrono::milliseconds(500) // 默认的开火间隔 #define FS_DEFAULT_FRAME_INTERVAL 10 // 默认的刷新频率，即每隔多少毫秒刷新一次 #define FS_DEFAULT_MOVE_STEP 0.01 // 在moveleft()方法和moveright()方法中默认的每次移动距离 #define FS_MOVE_LEFT_KEY &apos;a&apos; // 控制玩家飞机向左移动一个单位所对应的按键 #define FS_MOVE_RIGHT_KEY &apos;d&apos; // 控制玩家飞机向右移动一个单位所对应的按键 #define FS_ESCAPE_KEY &apos; &apos; // 退出游戏所使用的按键 #define FS_DEFAULT_BULLET_FLY_SPEED 3.0 // 默认子弹飞行速度，3代表每秒飞行三个屏幕 #define FS_DEFAULT_AIRCRAFT_FLY_SPEED 0.1 // 默认的飞机飞行速度 #define FS_DEFAULT_BULLET_COLOR fsColor(255,0,0,0) // 默认子弹颜色 #define FS_DEFAULT_BULLET_SIZE 0.1 //默认的子弹正方形边长 #define FS_DEFAULT_BULLET_SIZE_X 0.05 //默认的子弹长方形在x轴方向的长度 #define FS_DEFAULT_BULLET_SIZE_Y 0.1 //默认的子弹长方形在y轴方向的长度 #define FS_DEFAULT_PLAYER_SYMBOL &apos;*&apos; // 默认的玩家的飞机的符号 #define FS_DEFAULT_ENEMY_SYMBOL &apos;+&apos; // 默认的敌人的飞机的符号 #define FS_DEFAULT_BULLET_SYMBOL &apos;o&apos; // 默认的子弹的符号 #define FS_DEFAULT_SCOREBOARD_COLOR fsColor(0,255,0,0) // 默认的计分版颜色 // 默认的边界位置，这些位置主要在move*方法中限制物体不要超出屏幕边界 #define FS_DEFAULT_COORD_LOWER_LIMIT 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_X 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_X 0.95 #define FS_DEFAULT_COORD_LOWER_LIMIT_Y 0.05 #define FS_DEFAULT_COORD_UPPER_LIMIT_Y 0.95 // 飞机子弹来源 template&lt;typename T&gt; class fsPoint { public: T x, y; fsPoint() {}; fsPoint(T xval, T yval) :x(xval), y(yval) {}; fsPoint&lt;T&gt; &amp; operator = (const fsPoint&lt;T&gt; &amp; rval) { this-&gt;x = rval.x; this-&gt;y = rval.y; return *this; } }; //飞机子弹的来源 enum bulletSource { player = 1, enemy = 2, playerFriend = 3//分别来自玩家、敌方、玩家朋友 }; //子弹射击方向 enum direction { up = 1, down = 2, right = 3, left = 4 }; /*enum symbol { play = FS_DEFAULT_PLAYER_SYMBOL,en= FS_DEFAULT_ENEMY_SYMBOL,bullet=FS_DEFAULT_BULLET_SYMBOL }; */ class fsInvalidInitializePointValException : public std::logic_error { public: fsInvalidInitializePointValException() :std::logic_error(&quot;Invalid initialze fsPoints!&quot;) {}; }; class fsOutRangeMoveToPointException : public std::logic_error { public: fsOutRangeMoveToPointException() : std::logic_error(&quot;the move to point is out of the range of 0 to 1 for either x or y&quot;) {}; }; class fsInvalidFireTimeException :public std::logic_error { public: fsInvalidFireTimeException() :std::logic_error(&quot;Not right time to fire!&quot;) {}; }; class fsInvalidBulletSpeedInException : public std::logic_error { public: fsInvalidBulletSpeedInException() : std::logic_error(&quot;bullet speed in must be a positive number!&quot;) {}; }; class fsColor { public: unsigned char r, g, b, a; //全部为0~255 0 表示完全不透明 fsColor() {}; fsColor(unsigned char red, unsigned char green, unsigned char blue, unsigned char alpha) : r(red), g(green), b(blue), a(alpha) {}; }; //游戏中所用物体的基类 class fsObject { private: fsPoint&lt;double&gt; upperLeftCorner; // the position fsPoint&lt;double&gt; lowerRightCorner; fsColor foregroundColor; char symbol; int visible; // 物体是否可见，如果为0则不可见 public: fsObject() {}; //物体的位置、颜色、符号 fsObject(const fsPoint&lt;double&gt; &amp;upperleft, const fsPoint&lt;double&gt; &amp;lowerright, const fsColor &amp;fgc, char sym = 0) { if (upperleft.x &gt; lowerright.x || upperleft.y &gt; lowerright.y) throw fsInvalidInitializePointValException(); this-&gt;upperLeftCorner = upperleft; this-&gt;lowerRightCorner = lowerright; this-&gt;foregroundColor = fgc; this-&gt;symbol = sym; this-&gt;visible = 1; } //获得左上角位置 fsPoint&lt;double&gt; getUpperLeftCorner() const { return this-&gt;upperLeftCorner; } //获得右下角位置 fsPoint&lt;double&gt; getLowerRightCorner() const { return this-&gt;lowerRightCorner; } //获得符号 char getSymbol() const { return this-&gt;symbol; } //设置符号 void setSymbol(char c) { this-&gt;symbol = c; } //设置为可见 int getVisible() const { return this-&gt;visible; } //获得是否可见 void setVisible(int newVisible) { this-&gt;visible = newVisible; return; } // 移动位置，向左移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveleft() { if (this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP &lt; 0) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x - FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x - FS_DEFAULT_MOVE_STEP; return 1; } // 移动位置，向右移动一个单位（步长为FS_DEFAULT_MOVE_STEP） 移动成功则返回1 移动失败返回0 int moveright() { if (this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP &gt; 1) return 0; this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + FS_DEFAULT_MOVE_STEP; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + FS_DEFAULT_MOVE_STEP; return 1; } //检测竖直方向上移位是否正确 int moveVertically(double delta) { if (this-&gt;upperLeftCorner.y + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_UPPER_LIMIT_Y; return 0; } if (this-&gt;upperLeftCorner.y + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_Y) { this-&gt;upperLeftCorner.y = FS_DEFAULT_COORD_LOWER_LIMIT_Y; return 0; } this-&gt;upperLeftCorner.y = this-&gt;upperLeftCorner.y + delta; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.y + delta; return 1; } //在水平方向上移动位置，如果输入的delta导致物体的左上角超出屏幕，就将其置为最近的FS_DEFAULT_COORD_UPPER_LIMIT_X或FS_DEFAULT_COORD_UPPER_LIMIT_X int moveHorizontally(double delta) { if (this-&gt;upperLeftCorner.x + delta &gt; FS_DEFAULT_COORD_UPPER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_UPPER_LIMIT_X; return 0; } if (this-&gt;upperLeftCorner.x + delta &lt; FS_DEFAULT_COORD_LOWER_LIMIT_X) { this-&gt;upperLeftCorner.x = FS_DEFAULT_COORD_LOWER_LIMIT_X; return 0; } this-&gt;upperLeftCorner.x = this-&gt;upperLeftCorner.x + delta; this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + delta; return 1; } //将物体的右下角移动到一点 int movePoint(const fsPoint&lt;double&gt; &amp;dest) { if (dest.x &gt; 1 || dest.x &lt; 0 || dest.y &gt;1 || dest.y &lt; 0) { throw fsOutRangeMoveToPointException(); } this-&gt;lowerRightCorner.x = this-&gt;lowerRightCorner.x + dest.x - this-&gt;upperLeftCorner.x; this-&gt;lowerRightCorner.y = this-&gt;lowerRightCorner.x + dest.y - this-&gt;upperLeftCorner.y; this-&gt;upperLeftCorner = dest; } void printpos() const { cout &lt;&lt; &quot;ULC:&quot; &lt;&lt; (this-&gt;getLowerRightCorner()).x &lt;&lt; &quot; &quot; &lt;&lt; (this-&gt;getLowerRightCorner()).y &lt;&lt; endl; return; } }; //子弹类 class fsBullet :public fsObject { private: fsObject bullet; bulletSource source; direction bulletDirection; // 飞行方向 double vec; // 飞行速度，目前暂时不允许子弹斜着飞 并且不允许是负数 int bulletDamage; std::chrono::high_resolution_clock::time_point lastPositionUpdateTime; public: fsBullet() {}; fsBullet(bulletSource sourceOfBullet, direction directionOfBullet, int damageOfBullet, fsPoint&lt;double&gt; sourceulc, double bulletVec = FS_DEFAULT_BULLET_FLY_SPEED) : fsObject(sourceulc, fsPoint&lt;double&gt;(sourceulc.x + FS_DEFAULT_BULLET_SIZE_X, sourceulc.y + FS_DEFAULT_BULLET_SIZE_Y), FS_DEFAULT_BULLET_COLOR), source(sourceOfBullet), bulletDirection(directionOfBullet), bulletDamage(damageOfBullet), lastPositionUpdateTime(std::chrono::high_resolution_clock::now()) { if (bulletVec &lt; 0) throw fsInvalidBulletSpeedInException(); this-&gt;vec = bulletVec; if (this-&gt;bulletDirection == up) vec = vec * -1; bullet.setSymbol(FS_DEFAULT_BULLET_SYMBOL); } //更新子弹位置 int updataPosition() { std::chrono::microseconds timeelapsed = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::high_resolution_clock::now() - this-&gt;lastPositionUpdateTime); double delta = 1.0 * timeelapsed.count() / 1000000 * vec; //cout &lt;&lt; &quot;delta&quot; &lt;&lt; delta &lt;&lt; endl; this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); if (bullet.moveVertically(delta) == 0) return 0; return 1; } }; //所有飞机的基类 class fsAircraft :public fsObject { private: chrono::milliseconds fireInterval; // 两发炮弹之间的间隔，单位为ms chrono::steady_clock::time_point lastFireTime; int lifeLeft = 1; // 剩余的生命值 int bulletDamage = 1; // 默认的机体伤害值 bulletSource source; direction bullteDirection; public: fsAircraft() {}; fsAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsObject(upperleft, lowerright, fgc), fireInterval(fireinterval) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); }; inline int fireReady() { if (chrono::high_resolution_clock::now() - this-&gt;lastFireTime &gt; fireInterval) { return 1; } return 0; } // 强制发射子弹，返回fsBullet的对象，即该飞机所发射的子弹 fsBullet fire() { //if (fireReady()) { this-&gt;lastFireTime = chrono::high_resolution_clock::now(); return fsBullet(this-&gt;source, this-&gt;bullteDirection, this-&gt;bulletDamage, this-&gt;getUpperLeftCorner()); //} //throw fsInvalidFireTimeException(); } int setBullteDamage(int newBulletDamage) { this-&gt;bulletDamage = newBulletDamage; return 0; } // 设置飞机是玩家的飞机还是敌人的飞机 void setSource(bulletSource newSource) { this-&gt;source = newSource; } // 设置新的子弹飞行方向 void setFireDirection(direction newDirection) { this-&gt;bullteDirection = newDirection; } //返回剩余生命值，当返回0或者负数时说明死亡（本程序中没有使用） int getLifeLeft() const { return this-&gt;lifeLeft; } int gotHit(int bulletDamage = 1) { if (this-&gt;lifeLeft - bulletDamage &lt;= 0) { this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; return 0; } this-&gt;lifeLeft = this-&gt;lifeLeft - bulletDamage; } }; //玩家的飞机 class fsMyAircraft :public fsAircraft { public: fsMyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，发射子弹后，再经过此段时间后才能再次发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(player); this-&gt;setFireDirection(up); this-&gt;setSymbol(FS_DEFAULT_PLAYER_SYMBOL); }; }; //敌方的飞机 class fsEnemyAircraft : public fsAircraft { private: std::chrono::high_resolution_clock::time_point lastPositionUpdateTime; // 最后一次更新物体位置的时间 std::chrono::high_resolution_clock::time_point lastDirectionUpdateTime; // 最后一次更新运动方向的时间 double vec; // 飞行速度，指在水平方向上的飞行速度 std::chrono::milliseconds directionUpdateInterval; // 两次速度方向更新之间的时间间隔，最好能用随机数产生 public: fsEnemyAircraft(fsPoint&lt;double&gt; upperleft, // 飞机左上角的位置 fsPoint&lt;double&gt; lowerright, // 飞机右下角的位置 fsColor fgc, // 飞机的显示颜色，在控制台中此参数无效 std::chrono::milliseconds fireinterval = FS_DEFAULT_FIRE_INTERVAL // 飞机的子弹发射间隔，在经过此段时间后飞机才能发射子弹 ) : fsAircraft(upperleft, lowerright, fgc, fireinterval) { this-&gt;setSource(enemy); this-&gt;setFireDirection(down); this-&gt;setSymbol(FS_DEFAULT_ENEMY_SYMBOL); this-&gt;lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;directionUpdateInterval = std::chrono::milliseconds(1000); this-&gt;vec = FS_DEFAULT_AIRCRAFT_FLY_SPEED; } // 更新敌机的位置，敌机随机移动，每隔一段时间更换一个方向，移动会在一个矩形框中进行 int updatePosition() { // 是否要更换方向 if (std::chrono::high_resolution_clock::now() - lastDirectionUpdateTime &gt; directionUpdateInterval) { //产生一个新的方向 lastDirectionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;vec = this-&gt;vec * (-1); srand((unsigned)time(NULL)); directionUpdateInterval = std::chrono::milliseconds(rand() / 5 + 1000); // 随机数的范围在1s到7s之间 } std::chrono::milliseconds elapsedtime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - lastPositionUpdateTime); lastPositionUpdateTime = std::chrono::high_resolution_clock::now(); this-&gt;moveHorizontally(1.0 * elapsedtime.count() / 1000 * vec); return 0; } }; // 计分版 用于记录玩家的分数 class fsScoreBoard : public fsObject { private: int score = 0; // 每次击中算一分 public: fsScoreBoard() {}; fsScoreBoard(const fsPoint&lt;double&gt; &amp; upperleft, // 计分版左上角的位置 推荐将左上角的横坐标设置为大于1的数，避免分数的显示与游戏画面重叠 const fsPoint&lt;double&gt; &amp; lowerright, // 计分版右下角的位置 const fsColor &amp; fgc = FS_DEFAULT_SCOREBOARD_COLOR // 计分版颜色，在控制台情况下无效 ) :fsObject(upperleft, lowerright, fgc) { ; } // 获取计分版分数 int getCurScore() const { return this-&gt;score; } // 增加得分 void addScore(int delta = 1) { this-&gt;score = this-&gt;score + 1; } }; // 判断两个物体是否重叠 如果重叠将返回1 否则返回0，主要用来判定子弹是否击中了飞机 int fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) ; // 判断一个点是否在一个矩形中，包括在矩形边上的情况 template &lt;typename T&gt; bool fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight); int fsInitialize(); //int fsGameLoop(); } #endiffsDraw.h： #pragma once #include &quot;fsObject.h&quot; #include &lt;Windows.h&gt; #include &lt;conio.h&gt; #ifndef FSDRAW_H #define FSDRAW_H using namespace flightShooting; using namespace std; namespace flightShooting { #define FS_DEFAULT_CONSOLE_BUFFER_SCALE 50 //光标位置 void gotoxy(int x, int y) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos); } void gotoxy(int x, int y, HANDLE consoleBuf) { COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(consoleBuf, pos); } //设置颜色 void setcolor(WORD color) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color); } void setcolor(WORD color, HANDLE consoleBuf) { SetConsoleTextAttribute(consoleBuf, color); } //画出对象 int fsDraw(const fsObject &amp; fso) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED); cout &lt;&lt; fso.getSymbol(); return 0; } int fsDraw(const fsObject &amp; fso, HANDLE consoleBuf) { if (fso.getVisible() == 0) return 0; gotoxy((fso.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fso.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED, consoleBuf); cout &lt;&lt; fso.getSymbol(); return 0; } //画出计分板 int fsDrawScoreBoard(const fsScoreBoard &amp;fsb) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE); setcolor(FOREGROUND_GREEN); cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore(); return 0; } int fsDrawScoreBoard(const fsScoreBoard &amp; fsb, HANDLE consoleBuf) { if (fsb.getVisible() == 0) return 0; gotoxy((fsb.getUpperLeftCorner()).x * FS_DEFAULT_CONSOLE_BUFFER_SCALE, (fsb.getUpperLeftCorner()).y * FS_DEFAULT_CONSOLE_BUFFER_SCALE, consoleBuf); setcolor(FOREGROUND_GREEN, consoleBuf); cout &lt;&lt; &quot;SCORE: &quot; &lt;&lt; fsb.getCurScore(); return 0; } // 用空格填充控制台的缓存 int fsFillWithBlank() { gotoxy(0, 0); for (int i = 0; i &lt; 1000 * 1000; ++i) { cout &lt;&lt; &quot; &quot;; } return 0; } } #endiftest.h: int gameTestOneBuf() { // 初始化玩家飞机 fsMyAircraft playerAircraft = fsMyAircraft(fsPoint&lt;double&gt;(0.5, 0.99), fsPoint&lt;double&gt;(0.51, 1.00), fsColor(255, 255, 255, 0)); // 初始化敌方飞机 fsEnemyAircraft enemy1 = fsEnemyAircraft(fsPoint&lt;double&gt;(0.5, 0.10), fsPoint&lt;double&gt;(0.51, 0.11), fsColor(255, 0, 0, 0)); // 初始化计分板 fsScoreBoard scoreBoard = fsScoreBoard(fsPoint&lt;double&gt;(1.1, 0.3), fsPoint&lt;double&gt;(1.11, 0.31)); // 等待1s以便能够通过fire函数成功初始化子弹 Sleep(1000); fsBullet mybullet; if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } fsBullet enemybullet; if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } // 初始化键盘按键存储变量 char ch = &apos;/0&apos;; // 游戏循环 while (1) { // 获取按键 if (_kbhit()) { ch =_getche(); } // 依据不同的按键做出对应的反应 switch (ch) { case FS_MOVE_LEFT_KEY: playerAircraft.moveleft(); break; case FS_MOVE_RIGHT_KEY: playerAircraft.moveright(); break; case FS_ESCAPE_KEY: cout &lt;&lt; &quot;You ended this game!&quot;; return 0; default: break; } ch = 0; // 更新各对象的状态 if (playerAircraft.fireReady()) { mybullet = playerAircraft.fire(); } if (enemy1.fireReady()) { enemybullet = enemy1.fire(); } mybullet.updataPosition(); enemybullet.updataPosition(); enemy1.updatePosition(); // 呈现图像 system(&quot;cls&quot;); fsDraw(playerAircraft); fsDraw(mybullet); fsDraw(enemy1); fsDraw(enemybullet); fsDrawScoreBoard(scoreBoard); // 子弹击中的判定，如果子弹击中，则将原来的子弹设为不可见 if (fsOverlap(mybullet, enemy1)) { scoreBoard.addScore(); mybullet.setVisible(0); } if (fsOverlap(enemybullet, playerAircraft)) { cout &lt;&lt; &quot;you are hit!&quot;; enemybullet.setVisible(0); Sleep(500); } Sleep(FS_DEFAULT_FRAME_INTERVAL); } return 0; }fsObject.cpp: #include &quot;pch.h&quot; #include &lt;iostream&gt; #include &lt;iostream&gt; #include &lt;Windows.h&gt; #include &lt;chrono&gt; #include &lt;vector&gt; #include &lt;conio.h&gt; #include &quot;fsObject.h&quot; using namespace std; using namespace flightShooting; int flightShooting::fsOverlap(const fsObject &amp; obj1, const fsObject &amp; obj2) { if (obj1.getVisible() == 0 || obj2.getVisible() == 0) return 0; // 重叠判定要稍微费点脑筋 // 判断矩形是否重叠，只需要对每个矩形，分别判断其四个顶点是否在另外一个矩形内 const fsPoint&lt;double&gt; obj1ulc = obj1.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj1lrc = obj1.getLowerRightCorner(); const fsPoint&lt;double&gt; obj1urc = fsPoint&lt;double&gt;(obj1lrc.x, obj1ulc.y); const fsPoint&lt;double&gt; obj1llc = fsPoint&lt;double&gt;(obj1ulc.x, obj1lrc.y); const fsPoint&lt;double&gt; obj2ulc = obj2.getUpperLeftCorner(); const fsPoint&lt;double&gt; obj2lrc = obj2.getLowerRightCorner(); const fsPoint&lt;double&gt; obj2urc = fsPoint&lt;double&gt;(obj2lrc.x, obj2ulc.y); const fsPoint&lt;double&gt; obj2llc = fsPoint&lt;double&gt;(obj2ulc.x, obj2lrc.y); // bool test = fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj1InObj2 = fsPointInRect(obj1ulc, obj2ulc, obj2lrc) || fsPointInRect(obj1urc, obj2ulc, obj2lrc) || fsPointInRect(obj1llc, obj2ulc, obj2lrc) || fsPointInRect(obj1lrc, obj2ulc, obj2lrc); bool obj2InObj1 = fsPointInRect(obj2ulc, obj1ulc, obj1lrc) || fsPointInRect(obj2urc, obj1ulc, obj1lrc) || fsPointInRect(obj2llc, obj1ulc, obj1lrc) || fsPointInRect(obj2lrc, obj1ulc, obj1lrc); return obj1InObj2 || obj2InObj1; } template&lt;typename T&gt; bool flightShooting::fsPointInRect(fsPoint&lt;T&gt; point, fsPoint&lt;T&gt; RectUpperLeft, fsPoint&lt;T&gt; RectLowerRight) { return (point.x &gt;= RectUpperLeft.x &amp;&amp; point.x &lt;= RectLowerRight.x) &amp;&amp; (point.y &gt;= RectUpperLeft.y &amp;&amp; point.y &lt;= RectLowerRight.y); }fsTest.cpp: #include &lt;iostream&gt; #include &quot;pch.h&quot; #include &quot;fsObject.h&quot; #include &quot;fsTest.h&quot; using namespace std; using namespace flightShooting; int main() { gameTestOneBuf(); return 0;}","link":"/2019/08/31/飞机射击小游戏-1/"}],"tags":[{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[]}